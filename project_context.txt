PROJECT DIRECTORY STRUCTURE:
==============================
quantum-breach/
    eslint.config.js
    index.html
    package-lock.json
    package.json
    postcss.config.js
    report.html
    tailwind.config.js
    tsconfig.app.json
    tsconfig.json
    tsconfig.node.json
    vite.config.ts
    public/
    server/
        index.js
    src/
        App.tsx
        index.css
        main.tsx
        components/
            canvas/
                BackgroundScene.tsx
                ar/
                    ARControls.tsx
                    ARPlacement.tsx
                board/
                    QuantumBoard.tsx
                    QubitNode.tsx
                cells/
                    EmptyCell.tsx
                    FluxCell.tsx
                    LockedCell.tsx
                    StableCell.tsx
                effects/
                    VFXManager.tsx
                ui/
                    HoloGateCard.tsx
                    HolographicHUD.tsx
            dom/
                hud/
                    GameHUD.tsx
                    GateCard.tsx
                ui/
                    Loader.tsx
                    logo.tsx
        engine/
            ai/
                minimax.worker.ts
            core/
                GeometryManager.ts
                QuantumLogic.ts
        pages/
            GameGuide.tsx
            GameSession.tsx
            Home.tsx
            Lobby.tsx
            MinimaxInfo.tsx
            OfflineSetup.tsx
        store/
            gameStore.ts
==============================

FILE CONTENTS:
==============================


--- START OF FILE: eslint.config.js ---
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])

--- END OF FILE: eslint.config.js ---


--- START OF FILE: index.html ---
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>quantum-breach</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

--- END OF FILE: index.html ---


--- START OF FILE: package.json ---
{
  "name": "quantum-breach",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@react-three/drei": "^10.7.7",
    "@react-three/fiber": "^9.4.2",
    "@react-three/xr": "^6.6.28",
    "@types/three": "^0.182.0",
    "@types/uuid": "^10.0.0",
    "clsx": "^2.1.1",
    "cors": "^2.8.5",
    "express": "^5.2.1",
    "framer-motion": "^12.23.26",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-router-dom": "^7.11.0",
    "selfsigned": "^5.4.0",
    "socket.io": "^4.8.3",
    "socket.io-client": "^4.8.3",
    "tailwind-merge": "^3.4.0",
    "three": "^0.182.0",
    "uuid": "^13.0.0",
    "zustand": "^5.0.9"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/node": "^24.10.4",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-basic-ssl": "^2.1.0",
    "@vitejs/plugin-react": "^5.1.1",
    "autoprefixer": "^10.4.18",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "postcss": "^8.4.35",
    "tailwindcss": "^3.4.17",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.46.4",
    "vite": "^7.2.4"
  },
  "description": "This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.",
  "main": "eslint.config.js",
  "keywords": [],
  "author": "",
  "license": "ISC"
}

--- END OF FILE: package.json ---


--- START OF FILE: postcss.config.js ---
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
--- END OF FILE: postcss.config.js ---


--- START OF FILE: report.html ---
<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ูุณุชูุฏ ูู ูพุฑูฺู Quantum Breach</title>
    <style>
        :root {
            --bg-color: #0d1117;
            --text-color: #c9d1d9;
            --heading-color: #58a6ff;
            --accent-color: #238636;
            --code-bg: #161b22;
            --border-color: #30363d;
            --highlight: #f0883e;
            --card-bg: #161b22;
        }

        @font-face {
            font-family: 'Vazir';
            src: url('https://cdn.jsdelivr.net/gh/rastikerdar/vazir-font@v30.1.0/dist/Vazir.woff2') format('woff2');
        }

        body {
            font-family: 'Vazir', Tahoma, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.8;
            margin: 0;
            padding: 0;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Typography */
        h1, h2, h3, h4 {
            color: var(--heading-color);
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            font-weight: 700;
        }

        h1 {
            font-size: 2.5rem;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 10px;
            text-align: center;
            color: #fff;
            text-shadow: 0 0 10px rgba(88, 166, 255, 0.5);
        }

        h2 {
            font-size: 1.8rem;
            border-right: 5px solid var(--heading-color);
            padding-right: 15px;
            background: linear-gradient(270deg, rgba(88,166,255,0.1) 0%, transparent 100%);
            padding-top: 5px;
            padding-bottom: 5px;
        }

        h3 {
            font-size: 1.4rem;
            color: var(--highlight);
        }

        p {
            margin-bottom: 1em;
            text-align: justify;
        }

        /* Lists */
        ul, ol {
            margin-bottom: 1em;
            padding-right: 20px;
        }
        
        li {
            margin-bottom: 0.5em;
        }

        /* Code Blocks */
        pre {
            background-color: var(--code-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 15px;
            overflow-x: auto;
            direction: ltr;
            text-align: left;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 0.9rem;
            color: #e6edf3;
        }

        code {
            background-color: rgba(110, 118, 129, 0.4);
            padding: 2px 5px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.95em;
            color: #a5d6ff;
            direction: ltr;
            display: inline-block;
        }

        /* Cards & Info Boxes */
        .card {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .formula {
            background-color: #000;
            border-right: 4px solid var(--highlight);
            padding: 15px;
            margin: 15px 0;
            font-family: 'Times New Roman', serif;
            font-size: 1.1rem;
            text-align: center;
            direction: ltr;
            color: #fff;
        }

        /* Table of Contents */
        .toc {
            background-color: rgba(22, 27, 34, 0.8);
            border: 1px solid var(--border-color);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 40px;
        }

        .toc h3 {
            margin-top: 0;
            text-align: center;
        }

        .toc ul {
            list-style-type: none;
            padding: 0;
        }

        .toc li {
            margin: 10px 0;
            border-bottom: 1px dashed var(--border-color);
            padding-bottom: 5px;
        }

        .toc a {
            text-decoration: none;
            color: var(--text-color);
            transition: color 0.3s;
            display: block;
        }

        .toc a:hover {
            color: var(--heading-color);
            padding-right: 5px;
        }

        /* Footer */
        footer {
            margin-top: 50px;
            padding: 20px;
            text-align: center;
            border-top: 1px solid var(--border-color);
            font-size: 0.8rem;
            color: #8b949e;
        }

        /* Highlights */
        .badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: bold;
            margin-left: 5px;
        }
        .badge-ai { background-color: rgba(240, 136, 62, 0.2); color: #f0883e; }
        .badge-net { background-color: rgba(56, 139, 253, 0.2); color: #58a6ff; }
        .badge-ar { background-color: rgba(63, 185, 80, 0.2); color: #3fb950; }

    </style>
</head>
<body>

<div class="container">
    
    <!-- Title Page -->
    <header style="text-align: center; padding: 40px 0;">
        <div style="font-size: 4rem; margin-bottom: 10px;">โ๏ธ</div>
        <h1>ฺฏุฒุงุฑุด ูู ูพุฑูฺู Quantum Breach</h1>
        <p style="text-align: center; color: #8b949e;">ุชุญูู ูุนูุงุฑ ูุฑูโุงูุฒุงุฑุ ุงูฺฏูุฑุชูโูุง ููุด ูุตููุน ู ูพุงุฏูโุณุงุฒ ูุงูุนุช ุงูุฒูุฏู</p>
        <div style="margin-top: 20px;">
            <span class="badge badge-ai">Artificial Intelligence</span>
            <span class="badge badge-net">Multiplayer Networking</span>
            <span class="badge badge-ar">WebXR / AR</span>
        </div>
    </header>

    <!-- Table of Contents -->
    <nav class="toc">
        <h3>ููุฑุณุช ูุทุงูุจ</h3>
        <ul>
            <li><a href="#section-1">ฑ. ููุฏูู ู ูุนุฑู ูพุฑูฺู</a></li>
            <li><a href="#section-2">ฒ. ููุด ูุตููุน ู ุงูฺฏูุฑุชู Minimax (ุชุญูู ุนูู)</a></li>
            <li><a href="#section-3">ณ. ูุนูุงุฑ ฺูุฏููุฑู ู ููฺฏุงูโุณุงุฒ ูุทุน</a></li>
            <li><a href="#section-4">ด. ูพุงุฏูโุณุงุฒ ูุงูุนุช ุงูุฒูุฏู (WebXR)</a></li>
            <li><a href="#section-5">ต. ุฑูุฏุฑูฺฏ ู ุจูููโุณุงุฒ ฺฏุฑุงูฺฉ</a></li>
            <li><a href="#section-6">ถ. ูุชุฌูโฺฏุฑ</a></li>
        </ul>
    </nav>

    <!-- SECTION 1: INTRODUCTION -->
    <section id="section-1">
        <h2>ฑ. ููุฏูู ู ูุนุฑู ูพุฑูฺู</h2>
        <p>
            ูพุฑูฺู <strong>Quantum Breach</strong> ฺฉ ุจุงุฒ ุงุณุชุฑุงุชฺฺฉ ููุจุช (Turn-based Strategy) ุงุณุช ฺฉู ุจุง ุงููุงู ุงุฒ ููุงูู ูุญุงุณุจุงุช ฺฉูุงูุชูู ู ุงููุช ุณุงุจุฑ ุทุฑุงุญ ุดุฏู ุงุณุช. ุงู ูพุฑูฺู ุจุฑ ุฑู ูพูุชูุฑู ูุจ ุงุฌุฑุง ูโุดูุฏ ู ูุฏู ุขู ุงุฑุงุฆู ฺฉ ุชุฌุฑุจู ฺฏุฑุงูฺฉ ุณุทุญ ุจุงูุง (High-end) ุจุง ุงุณุชูุงุฏู ุงุฒ ุชฺฉููููฺโูุง ูุฏุฑู ูุจ ุงุณุช.
        </p>
        
        <div class="card">
            <h3>๐ ูพุดุชู ุชฺฉููููฺ (Tech Stack)</h3>
            <ul>
                <li><strong>Frontend Framework:</strong> React 19 (ูุฏุฑุช UI ู State)</li>
                <li><strong>3D Engine:</strong> Three.js + React Three Fiber (ุฑูุฏุฑูฺฏ ุณู ุจุนุฏ)</li>
                <li><strong>State Management:</strong> Zustand (ูุฏุฑุช ูุถุนุช ุณุฑุงุณุฑ)</li>
                <li><strong>Build Tool:</strong> Vite (ุจูุฏ ุณุฑุน ู HMR)</li>
                <li><strong>Styling:</strong> Tailwind CSS (ุงุณุชุงูโุฏู ูุฏุฑู UI)</li>
                <li><strong>Language:</strong> TypeScript (ุชุงูพโุฏู ุงุณุชุงุชฺฉ ุจุฑุง ุงููุช ฺฉุฏ)</li>
                <li><strong>XR/AR:</strong> WebXR + React Three XR (ูุงูุนุช ุงูุฒูุฏู)</li>
                <li><strong>Backend:</strong> Node.js + Express + Socket.io (ุณุฑูุฑ ฺูุฏููุฑู ุจูุงุฏุฑูฺฏ)</li>
            </ul>
        </div>

        <p>
            ูุณุชู ุงุตู ุจุงุฒ ุจุฑ ุฑู ฺฉ ุดุจฺฉู ถรถ ุจูุง ุดุฏู ุงุณุช ฺฉู ุจุงุฒฺฉูุงู (Hacker vs AI/Security) ุชูุงุด ูโฺฉููุฏ ุจุง ุงุณุชูุงุฏู ุงุฒ ุณู ููุน ฺฏุช ููุทู (Firewall, Injector, Virus) ฺฉูุชุฑู ุจุชโูุง ฺฉูุงูุชูู (Qubits) ุฑุง ุฏุฑ ุฏุณุช ุจฺฏุฑูุฏ. ฺุงูุด ูู ุงุตู ุฏุฑ ุงู ูพุฑูฺูุ ูพุงุฏูโุณุงุฒ ฺฉ ููุด ูุตููุน ูุฏุฑุชููุฏ ุฏุฑ ูุฑูุฑฺฏุฑ ุจุฏูู ูุณุฏูุฏ ฺฉุฑุฏู ุชุฑุฏ ุงุตู (Main Thread) ู ููฺูู ุงุฌุงุฏ ฺฉ ุชุฌุฑุจู ฺูุฏููุฑู ุจุฏูู ุชุงุฎุฑ ุจุง ุงุณุชูุงุฏู ุงุฒ ููฺฏุงูโุณุงุฒ ูุทุน ุจูุฏู ุงุณุช.
        </p>
    </section>

    <!-- END OF PART 1 -->
     <!-- SECTION 2: AI & MINIMAX -->
    <section id="section-2">
        <h2>ฒ. ููุด ูุตููุน ู ุงูฺฏูุฑุชู Minimax (ุชุญูู ุนูู)</h2>
        <p>
            ูุบุฒ ูุชูฺฉุฑ ุจุงุฒ Quantum Breach ฺฉ ููุชูุฑ ููุด ูุตููุน ุณูุงุฑุด ุงุณุช ฺฉู ุจุฑ ูพุงู ุงูฺฏูุฑุชู <strong>Minimax</strong> ููุฑุงู ุจุง <strong>ูุฑุณ ุขููุง-ุจุชุง (Alpha-Beta Pruning)</strong> ุจูุง ุดุฏู ุงุณุช. ุจุฑุฎูุงู ุจุณุงุฑ ุงุฒ ุจุงุฒโูุง ูุจ ฺฉู ุงุฒ ููุทูโูุง ุณุงุฏู "if-else" ุงุณุชูุงุฏู ูโฺฉููุฏุ ุงู AI ุฏุฑุฎุช ุจุงุฒ ุฑุง ุชุง ุนูู ูุดุฎุต (ุจู ด ุชุง ถ ูุงู ุจุณุชู ุจู ุณุฎุช) ุดุจูโุณุงุฒ ูโฺฉูุฏ.
        </p>

        <h3>ฒ.ฑ. ูุฏูโุณุงุฒ ุฑุงุถ ู ุชุงุจุน ูุทููุจุช (Utility Function)</h3>
        <p>
            ุจุฑุง ุงูฺฉู ููุด ูุตููุน ุจุชูุงูุฏ ุจู ูุถุนุชโูุง "ุฎูุจ" ู "ุจุฏ" ุชูุงุฒ ูุงุฆู ุดูุฏุ ุงุฒ ฺฉ ุชุงุจุน ุงุฑุฒุงุจ (Evaluation Function) ูุทุน ุงุณุชูุงุฏู ูโฺฉูุฏ. ุงู ุชุงุจุน ุจู ูุฑ ูุถุนุช ุตูุญู ($s$) ฺฉ ุงูุชุงุฒ ุนุฏุฏ ($U(s)$) ูุณุจุช ูโุฏูุฏ. ูุฑููู ฺฉู ูุญุงุณุจู ูุทููุจุช ุจู ุตูุฑุช ุฒุฑ ุงุณุช:
        </p>

        <div class="formula">
            U(s) = (W_m \cdot M(s)) + (W_p \cdot P(s)) + (W_c \cdot C(s)) - (W_t \cdot T(s))
        </div>

        <p>ฺฉู ุฏุฑ ุขู:</p>
        <ul>
            <li><strong>$M(s)$ (Material):</strong> ุงุฑุฒุด ุฎุงูุต ููุฑูโูุง. ฺฏุชโูุง ููู ุดุฏู (Locked) ุจู ุฏูู ูููุฐูุงูพุฐุฑุ ุถุฑุจ ณ ุจุฑุงุจุฑ ูุณุจุช ุจู ฺฏุชโูุง ูุนููู (Stable) ุฏุงุฑูุฏ.</li>
            <li><strong>$P(s)$ (Positional):</strong> ุงุฑุฒุด ูููุนุช ุจุฑ ุงุณุงุณ <em>Heatmap</em>. ุฎุงููโูุง ูุฑฺฉุฒ ุตูุญู ุงุฑุฒุด ุงุณุชุฑุงุชฺฺฉ ุจุงูุงุชุฑ ุฏุงุฑูุฏ ุฒุฑุง ุฏุณุชุฑุณ ุจู ููุณุงฺฏุงู ุจุดุชุฑ ุฑุง ูุฑุงูู ูโฺฉููุฏ.</li>
            <li><strong>$C(s)$ (Clustering):</strong> ุงูุชุงุฒ ุฎูุดูโุจูุฏ. ููุด ูุตููุน ุจุฑุง ุงุฌุงุฏ ุฒูุฌุฑูโุง ุงุฒ ููุฑูโูุง ูุชุตู ุจู ูู ูพุงุฏุงุด ูโฺฏุฑุฏ (ุฏูุงุน ุฌูุน).</li>
            <li><strong>$T(s)$ (Threats):</strong> ุฌุฑูู ุจุฑุง ุชูุฏุฏุงุช ุญุฑู. ุงฺฏุฑ ููุฑูโูุง ุญุฑู ุฏุฑ ูููุนุช ุญููู ูุฑุงุฑ ุฏุงุดุชู ุจุงุดูุฏุ ุงูุชุงุฒ ฺฉุณุฑ ูโุดูุฏ.</li>
        </ul>

        <div class="card">
            <h4>๐ก ูพุงุฏูโุณุงุฒ Heatmap (ููุดู ุญุฑุงุฑุช)</h4>
            <p>ุขุฑุงู ุฒุฑ ฺฉู ุฏุฑ ฺฉุฏ <code>minimax.worker.ts</code> ุชุนุฑู ุดุฏู ุงุณุชุ ุงุฑุฒุด ุฐุงุช ูุฑ ุฎุงูู ุงุฒ ุดุจฺฉู ถรถ ุฑุง ูุดุงู ูโุฏูุฏ. ุงุนุฏุงุฏ ุจุฒุฑฺฏุชุฑ (12) ูุดุงูโุฏููุฏู ูุฑฺฉุฒ ุตูุญู ู ุงุนุฏุงุฏ ฺฉูฺฺฉุชุฑ (2) ูุดุงูโุฏููุฏู ฺฏูุดูโูุง ฺฉูโุงุฑุฒุด ูุณุชูุฏ:</p>
            <pre><code>const POSITION_VALUES = new Int8Array([
  2,  3,  4,  4,  3,  2,
  3,  6,  8,  8,  6,  3,
  4,  8, 12, 12,  8,  4,
  4,  8, 12, 12,  8,  4,
  3,  6,  8,  8,  6,  3,
  2,  3,  4,  4,  3,  2
]);</code></pre>
        </div>

        <h3>ฒ.ฒ. ูุฏุฑุช ุนุฏู ูุทุนุช (Probabilistic Logic)</h3>
        <p>
            ฺฉ ุงุฒ ฺุงูุดโูุง ุงุตู ุฏุฑ Quantum Breachุ ูุฌูุฏ ฺฏุช <strong>Injector (X)</strong> ุงุณุช ฺฉู ุฏุฑ ุญููุงุช ูุทุฑ ตฐูช ุงุญุชูุงู ุดฺฉุณุช ุฏุงุฑุฏ. ุงูฺฏูุฑุชู Minimax ฺฉูุงุณฺฉ ุจุฑุง ุจุงุฒโูุง ูุทุน (Deterministic) ุทุฑุงุญ ุดุฏู ุงุณุช. ุจุฑุง ุญู ุงู ูุดฺฉูุ ูุง ุงุฒ ููููู <strong>ุงูุฏ ุฑุงุถ ูุทููุจุช (Expected Utility)</strong> ุงุณุชูุงุฏู ฺฉุฑุฏูโุงู.
        </p>
        <p>
            ููฺฏุงู ฺฉู ููุด ูุตููุน ุญุฑฺฉุช ุฑุง ุจุฑุฑุณ ูโฺฉูุฏ ฺฉู ุดุงูู ุดุงูุณ ุงุณุชุ ุดุงุฎู ุฏุฑุฎุช ุจุงุฒ ุจู ุฏู ุฒุฑุดุงุฎู ุชูุณู ูโุดูุฏ (ููููุช ู ุดฺฉุณุช). ุงุฑุฒุด ุขู ฺฏุฑู ุจุฑุงุจุฑ ุงุณุช ุจุง ูุงูฺฏู ูุฒู ูุชุงุฌ:
        </p>

        <div class="formula">
            EU(action) = \sum_{i} P(outcome_i) \times U(outcome_i)
        </div>

        <p>
            ุฏุฑ ุณูุงุฑู Injector ูุทุฑุ ุงู ูุฑููู ุจู ุตูุฑุช ุฒุฑ ุณุงุฏู ูโุดูุฏ:
        </p>
        <div class="formula">
            EU = (0.5 \times U_{success}) + (0.5 \times U_{fail})
        </div>

        <h3>ฒ.ณ. ููุฑุณุชฺฉโูุง ูพุดุฑูุชู: ูุฏุฑุช ุขูุชุฑููพ</h3>
        <p>
            ููุด ูุตููุน ุฏุงุฑุง ฺฉ "ููู" ุงุฒ ูฺฉุงูฺฉ ูุฑููพุงุด ฺฉูุงูุชูู (Quantum Collapse) ุจุงุฒ ุงุณุช. ุงู ููุถูุน ุฏุฑ ูุญูู ุงุณุชูุงุฏู ุงุฒ ฺฏุชโูุง <strong>Virus (H)</strong> ู <strong>Firewall (Z)</strong> ูููุฏ ูพุฏุง ูโฺฉูุฏ:
        </p>
        <ul>
            <li>
                <strong>ุงุณุชุฑุงุชฺ ุจุฑุฏ (Winning State):</strong> ุงฺฏุฑ AI ุฌูู ุจุงุดุฏุ ูุฏูุด <em>ฺฉุงูุด ูุงุฑุงูุณ</em> ุงุณุช. ุงู ุงุฒ Firewall ุงุณุชูุงุฏู ูโฺฉูุฏ ุชุง ูุถุนุช ุฑุง ุชุซุจุช ฺฉุฑุฏู ู ุดุงูุณ ุจุงุฒฺฏุดุช ุญุฑู ุฑุง ุจู ุตูุฑ ุจุฑุณุงูุฏ.
            </li>
            <li>
                <strong>ุงุณุชุฑุงุชฺ ุจุงุฎุช (Losing State):</strong> ุงฺฏุฑ AI ุนูุจ ุจุงุดุฏุ ูุฏูุด <em>ุงูุฒุงุด ูุงุฑุงูุณ</em> ุงุณุช. ุงู ุงุฒ Virus ุงุณุชูุงุฏู ูโฺฉูุฏ ุชุง ููุฑูโูุง ูพุงุฏุงุฑ ุญุฑู ุฑุง ุจู ุญุงูุช Flux (ูุงูพุงุฏุงุฑ) ุจุจุฑุฏ. ุงู ฺฉุงุฑ ูุชุฌู ูุทุน ุจุงุฎุช ุฑุง ุจู ฺฉ ููุงุฑ ตฐ/ตฐ ุชุจุฏู ูโฺฉูุฏ.
            </li>
        </ul>

        <h3>ฒ.ด. ุจูููโุณุงุฒโูุง ูู (Web Workers & TypedArrays)</h3>
        <p>
            ูุญุงุณุจุงุช Minimax ุจุณุงุฑ ุณูฺฏู ูุณุชูุฏ. ุจุฑุง ุฌููฺฏุฑ ุงุฒ ูุฑุฒ ุดุฏู ุฑุงุจุท ฺฉุงุฑุจุฑ (UI) ู ุฑุณุฏู ุจู ุณุฑุนุช ถฐ ูุฑู ุจุฑ ุซุงููุ ูุนูุงุฑ ุฒุฑ ูพุงุฏูโุณุงุฒ ุดุฏู ุงุณุช:
        </p>
        <ol>
            <li><strong>Web Worker ุงุฎุชุตุงุต:</strong> ุชูุงู ููุทู ูุญุงุณุจุงุช ุฏุฑ ฺฉ ุชุฑุฏ ุฌุฏุงฺฏุงูู (<code>minimax.worker.ts</code>) ุงุฌุฑุง ูโุดูุฏ.</li>
            <li><strong>ุขุฑุงูโูุง ููุนโุฏุงุฑ (TypedArrays):</strong> ุจู ุฌุง ุงุณุชูุงุฏู ุงุฒ ุขุฑุงูโูุง ูุนููู ุฌุงูุงุงุณฺฉุฑูพุชุ ุงุฒ <code>Int8Array</code> ุจุฑุง ููุงุด ุตูุญู ุจุงุฒ ุงุณุชูุงุฏู ุดุฏู ุงุณุช. ุงู ฺฉุงุฑ ูุตุฑู ุญุงูุธู ุฑุง ฺฉุงูุด ุฏุงุฏู ู ุณุฑุนุช ฺฉูพ ฺฉุฑุฏู ุขุฑุงู (Cloning) ุฑุง ุฏุฑ ุญู ุดุจูโุณุงุฒ ุฏุฑุฎุช ุจุงุฒ ุจู ุดุฏุช ุงูุฒุงุด ูโุฏูุฏ.</li>
            <li><strong>ฺฉุด ููุณุงฺฏุงู (Neighbors Cache):</strong> ูุณุช ููุณุงฺฏุงู ูุฑ ุณููู (ฺฉู ุซุงุจุช ุงุณุช) ุฏุฑ ุดุฑูุน ุจุงุฒ ูพุดโูุญุงุณุจู ุดุฏู ู ุฏุฑ ฺฉ ุขุฑุงู ฺฉโุจุนุฏ ููุช (Flat Array) ุฐุฎุฑู ูโุดูุฏ ุชุง ุงุฒ ุฌุณุชุฌู ูพุฑูุฒูู ุฏุฑ ูุฑ ูุฑู ุฌููฺฏุฑ ุดูุฏ.</li>
        </ol>

        <div class="card">
            <h4>โก๏ธ ุชฺฉูฺฉ Transferable Objects</h4>
            <p>
                ููฺฏุงู ุงุฑุณุงู ุฏุงุฏูโูุง ุจู Thread ุงุตู ู Workerุ ุงุฒ ุชฺฉูฺฉ Transferable Objects ุงุณุชูุงุฏู ุดุฏู ุงุณุช. ุงู ุนู ุจุงูุฑ ุญุงูุธู (Buffer) ุจู ุฌุง ฺฉูพ ุดุฏูุ ูุณุชููุงู ุจู Worker ููุชูู ูโุดูุฏ ฺฉู ุณุฑุจุงุฑ (Overhead) ุงุฑุชุจุงุท ุฑุง ุจู ูุฒุฏฺฉ ุตูุฑ ูโุฑุณุงูุฏ.
            </p>
        </div>
    </section>
    <!-- SECTION 3: MULTIPLAYER ARCHITECTURE -->
    <section id="section-3">
        <h2>ณ. ูุนูุงุฑ ฺูุฏููุฑู ู ููฺฏุงูโุณุงุฒ ูุทุน</h2>
        <p>
            ุจุฎุด ฺูุฏููุฑู ุจุงุฒ Quantum Breach ุจุฑ ูพุงู ูพุฑูุชฺฉู <strong>WebSocket</strong> (ุจุง ุงุณุชูุงุฏู ุงุฒ ฺฉุชุงุจุฎุงูู <code>Socket.io</code>) ูพุงุฏูโุณุงุฒ ุดุฏู ุงุณุช. ุณุฑูุฑ ุจุงุฒ (ููุดุชู ุดุฏู ุจุง Node.js) ูุธูู ูุฏุฑุช ุงุชุงูโูุง (Rooms)ุ ุงุชุตุงู ุจุงุฒฺฉูุงู (Matchmaking) ู ุฑูู ฺฉุฑุฏู ูพุงูโูุง ุฑุง ุจุฑ ุนูุฏู ุฏุงุฑุฏุ ุงูุง ููุทู ูุฒฺฉ ู ูุญุงุณุจุงุช ุจุงุฒ ุฏุฑ ุณูุช ฺฉูุงูุช (Client-side) ุงูุฌุงู ูโุดูุฏ.
        </p>

        <h3>ณ.ฑ. ููฺฏุงูโุณุงุฒ ูุถุนุช ูุทุน (Deterministic State Sync)</h3>
        <p>
            ฺฉ ุงุฒ ฺุงูุดโูุง ุจุงุฒโูุง ุขููุงูุ ููฺฏุงู ูฺฏู ุฏุงุดุชู ูุถุนุช ุจุงุฒ ุจู ุฏู ุจุงุฒฺฉู ุงุณุช. ุจู ุฌุง ุงุฑุณุงู ฺฉู ูุถุนุช ุตูุญู (ฺฉู ุดุงูู ณถ ุขุจุฌฺฉุช ูพฺุฏู ุงุณุช) ุฏุฑ ูุฑ ูุฑูุ ูุง ุงุฒ ุงูฺฏู <strong>Input Streaming</strong> ุงุณุชูุงุฏู ฺฉุฑุฏูโุงู.
        </p>
        <p>
            ุฏุฑ ุงู ุฑูุดุ ุชููุง "ูุฑูุฏโูุง ฺฉุงุฑุจุฑ" ู ฺฉ "Seed ุชุตุงุฏู" ุงุฑุณุงู ูโุดูุฏ. ุงุฒ ุขูุฌุง ฺฉู ููุทู ุจุงุฒ ูุทุน (Deterministic) ุงุณุชุ ุงฺฏุฑ ูุฑ ุฏู ฺฉูุงูุช ุจุง ฺฉ ูุถุนุช ุงููู ฺฉุณุงู ู ูุฑูุฏโูุง ฺฉุณุงู (ุจู ููุฑุงู ุงุนุฏุงุฏ ุชุตุงุฏู ฺฉุณุงู) ุดุฑูุน ฺฉููุฏุ ูุชุฌู ููุง ุฏุฑ ูุฑ ุฏู ุณุณุชู ุฏููุงู ฺฉุณุงู ุฎูุงูุฏ ุจูุฏ.
        </p>

        <div class="card">
            <h4>๐ ููุด Seed ุฏุฑ ููฺฏุงูโุณุงุฒ RNG</h4>
            <p>
                ุจุงุฒ ุฏุงุฑุง ุงููุงูโูุง ุดุงูุณ ุงุณุช (ูุงููุฏ ุงุญุชูุงู ตฐูช ุฏุฑ ฺฏุช Injector). ุงฺฏุฑ ุจุงุฒฺฉู A ฺฉ ุนุฏุฏ ุชุตุงุฏู ุชููุฏ ฺฉูุฏ ู ูููู ุดูุฏุ ุงูุง ุจุงุฒฺฉู B ุนุฏุฏ ูุชูุงูุช ุชููุฏ ฺฉูุฏ ู ุดฺฉุณุช ุจุฎูุฑุฏุ ุจุงุฒ ุงุฒ ููฺฏุงูโุณุงุฒ ุฎุงุฑุฌ ูโุดูุฏ (Desync).
            </p>
            <p>
                ุจุฑุง ุญู ุงู ูุดฺฉูุ ฺฉูุงูุช ุดุฑูุนโฺฉููุฏู ุญุฑฺฉุชุ ฺฉ <code>seed</code> ุชุตุงุฏู ุชููุฏ ฺฉุฑุฏู ู ููุฑุงู ุญุฑฺฉุช ุงุฑุณุงู ูโฺฉูุฏ. ูุฑ ุฏู ฺฉูุงูุช ุงุฒ ฺฉ ุชุงุจุน PRNG ุณูุงุฑุด (ูุงููุฏ <code>mulberry32</code>) ุงุณุชูุงุฏู ูโฺฉููุฏ ฺฉู ุจุง ุฏุฑุงูุช ุงู Seedุ ุฏูุจุงููโุง ุงุฒ ุงุนุฏุงุฏ ุชุตุงุฏู <strong>ฺฉุงููุงู ูุดุงุจู</strong> ุชููุฏ ูโฺฉูุฏ.
            </p>
            <pre><code>// QuantumLogic.ts
// ุงู ุชุงุจุน ุฏุฑ ูุฑ ุฏู ฺฉูุงูุช ุจุง seed ุฏุฑุงูุช ุงุฒ ุดุจฺฉู ุงุฌุฑุง ูโุดูุฏ
export const mulberry32 = (a: number) => {
  return () => {
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    // ... ูุญุงุณุจุงุช ุจุช ุจุฑุง ุชููุฏ ุนุฏุฏ ุดุจูโุชุตุงุฏู
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  }
};</code></pre>
        </div>

        <h3>ณ.ฒ. ุณุงุฎุชุงุฑ ูพุงูโูุง ุดุจฺฉู (Payload Structure)</h3>
        <p>
            ุจุฑุง ุจูููโุณุงุฒ ูพููุง ุจุงูุฏุ ูพุงูโูุง ุชุจุงุฏู ุดุฏู ุจุณุงุฑ ฺฉูโุญุฌู ูุณุชูุฏ. ฺฉ ุจุณุชู ุฏุงุฏู ูุนููู ุจุฑุง ุงูุฌุงู ุญุฑฺฉุช ุจู ุดฺฉู ุฒุฑ ุงุณุช:
        </p>
        <pre><code>interface MovePayload {
  roomId: string;  // ุดูุงุณู ุงุชุงู ุจุงุฒ
  nodeId: number;  // ุงูุฏฺฉุณ ุณููู (0 ุชุง 35)
  gate: 'Z' | 'X' | 'H'; // ููุน ฺฏุช ุงุณุชูุงุฏู ุดุฏู
  seed: number;    // ุนุฏุฏ ุจุฐุฑ ุจุฑุง ููฺฏุงูโุณุงุฒ ุดุงูุณ
}</code></pre>

        <h3>ณ.ณ. ุงุนุชุจุงุฑุณูุฌ ุณูุช ุณุฑูุฑ (Server-Side Validation)</h3>
        <p>
            ุงฺฏุฑฺู ูุญุงุณุจุงุช ุฏุฑ ฺฉูุงูุช ุงูุฌุงู ูโุดูุฏุ ุณุฑูุฑ (<code>server/index.js</code>) ููุด "ุญููุช ูุฑุฌุน" (Authoritative Source) ุฑุง ุจุฑุง ููุงูู ูพุงู ุงูุง ูโฺฉูุฏ ุชุง ุงุฒ ุชููุจ ุฌููฺฏุฑ ุดูุฏ:
        </p>
        <ul>
            <li><strong>ุจุฑุฑุณ ููุจุช (Turn Validation):</strong> ุณุฑูุฑ ฺฺฉ ูโฺฉูุฏ ฺฉู ุขุง ูุงูุนุงู ููุจุช ุจุงุฒฺฉู ุงุณุช ฺฉู ุฏุฑุฎูุงุณุช ุฑุง ุงุฑุณุงู ฺฉุฑุฏู ุง ุฎุฑ.</li>
            <li><strong>ุจุฑุฑุณ ููุงูู ุญุฑฺฉุช:</strong> ุณุฑูุฑ ุงุทููุงู ุญุงุตู ูโฺฉูุฏ ฺฉู ุณููู ููุตุฏ ุฎุงู ุงุณุช ู ููุน ฺฏุช ูุนุชุจุฑ ุงุณุช.</li>
            <li><strong>ูุญุฏูุฏุช ูุฑุฎ (Rate Limiting):</strong> ุจุฑุง ุฌููฺฏุฑ ุงุฒ ุญููุงุช Spam ุง DoSุ ุณุฑูุฑ ุชุนุฏุงุฏ ุฏุฑุฎูุงุณุชโูุง ุฏุฑ ุซุงูู ุฑุง ุจุฑุง ูุฑ ุณูฺฉุช ูุญุฏูุฏ ูโฺฉูุฏ.</li>
        </ul>

        <h3>ณ.ด. ูุฏุฑุช ูุทุน ุงุชุตุงู (Disconnection Handling)</h3>
        <p>
            ุณุณุชู ุฏุงุฑุง ูฺฉุงูุฒูโูุง ุจุงุฒุงุจ (Reconnection) ุงุณุช. ุงฺฏุฑ ุงุฑุชุจุงุท ฺฉ ุจุงุฒฺฉู ูุทุน ุดูุฏ:
        </p>
        <ol>
            <li>ุณุฑูุฑ ุฑูุฏุงุฏ <code>player_left</code> ุฑุง ุจุฑูุฏฺฉุณุช ูโฺฉูุฏ.</li>
            <li>ฺฉูุงูุช ููุงุจู ูุงุฑุฏ ุญุงูุช "ุงูุชุธุงุฑ" ุดุฏู ู UI ูุถุนุช "Signal Lost" ุฑุง ููุงุด ูโุฏูุฏ.</li>
            <li>ฺฉูุงูุช ูุทุน ุดุฏู ุจู ุตูุฑุช ุฎูุฏฺฉุงุฑ ุชูุงุด ูโฺฉูุฏ ุชุง ต ุจุงุฑ ูุฌุฏุฏุงู ูุชุตู ุดูุฏ.</li>
            <li>ุงฺฏุฑ ุงุชุตุงู ุจุฑูุฑุงุฑ ูุดูุฏุ ุจุงุฒ ุฎุงุชูู ูโุงุจุฏ.</li>
        </ol>
    </section>
    <!-- SECTION 4: AUGMENTED REALITY (WebXR) -->
    <section id="section-4">
        <h2>ด. ูพุงุฏูโุณุงุฒ ูุงูุนุช ุงูุฒูุฏู (WebXR)</h2>
        <p>
            ูพุฑูฺู Quantum Breach ุงุฒ ุงุณุชุงูุฏุงุฑุฏ <strong>WebXR</strong> ุจุฑุง ุงุฑุงุฆู ุชุฌุฑุจู ูุงูุนุช ุงูุฒูุฏู (AR) ุจุฏูู ูุงุฒ ุจู ูุตุจ ุงูพูฺฉุดู ุจูู ุงุณุชูุงุฏู ูโฺฉูุฏ. ุงู ูพุงุฏูโุณุงุฒ ุจุง ุงุณุชูุงุฏู ุงุฒ ฺฉุชุงุจุฎุงูู <code>@react-three/xr</code> ุงูุฌุงู ุดุฏู ุงุณุช ฺฉู ูพู ูุงู React Three Fiber ู APIูุง ุณุทุญ ูพุงู WebXR ุงุฌุงุฏ ูโฺฉูุฏ.
        </p>

        <h3>ด.ฑ. ุชุดุฎุต ุณุทุญ (Hit-Testing)</h3>
        <p>
            ูุณุชู ุงุตู ุชุฌุฑุจู ARุ ูุงุจูุช ุชุดุฎุต ุณุทูุญ ูุฒฺฉ (ูุงููุฏ ูุฒ ุง ุฒูู) ุงุณุช. ูุง ุงุฒ ูุงุจูุช <strong>Hit-Test</strong> ุฏุฑ WebXR ุงุณุชูุงุฏู ูโฺฉูู. ุฏุฑ ุงู ูุฑุขูุฏุ ุฏุณุชฺฏุงู ุฏุงุฆูุงู ูพุฑุชููุง (Rays) ุฑุง ุงุฒ ุฏูุฑุจู ุจู ุฏูุง ูุงูุน ูโูุฑุณุชุฏ ุชุง ููุงุท ุจุฑุฎูุฑุฏ ุจุง ุณุทูุญ ูุณุทุญ ุฑุง ูพุฏุง ฺฉูุฏ.
        </p>
        <p>
            ุฏุฑ ฺฉุงููพูููุช <code>ARPlacement.tsx</code>ุ ููฺฉ <code>useXRHitTest</code> ูุงุชุฑุณ ูููุนุช ุฏูุง ูุงูุน ุฑุง ุฏุฑ ูุฑ ูุฑู ุฏุฑุงูุช ูโฺฉูุฏ:
        </p>
        <pre><code>useXRHitTest((results, getWorldMatrix) => {
  if (isARPlaced) return; // ุงฺฏุฑ ุจุงุฒ ุดุฑูุน ุดุฏูุ ูพุฑุฏุงุฒุด ูุชููู ุดูุฏ

  if (results.length > 0) {
    // ุฏุฑุงูุช ูุงุชุฑุณ ูููุนุช ุณุทุญ ุชุดุฎุต ุฏุงุฏู ุดุฏู
    const hitMatrix = new THREE.Matrix4();
    getWorldMatrix(hitMatrix, results[0]);

    // ุชุฌุฒู ูุงุชุฑุณ ุจุฑุง ุงุณุชุฎุฑุงุฌ ูููุนุช ู ฺุฑุฎุด
    hitMatrix.decompose(
      reticleRef.current.position,
      reticleRef.current.quaternion,
      reticleRef.current.scale
    );
  }
}, 'viewer');</code></pre>

        <h3>ด.ฒ. ุณุณุชู ุฑุชฺฉู ู ููฺฏุฑ (Reticle & Anchoring)</h3>
        <p>
            ุจุฑุง ุฑุงูููุง ฺฉุงุฑุจุฑุ ฺฉ ุญููู ุณุจุฒ ุฑูฺฏ (Reticle) ุทุฑุงุญ ุดุฏู ฺฉู ุฑู ุณุทูุญ ุชุดุฎุต ุฏุงุฏู ุดุฏู ูโูุบุฒุฏ. ูุฑุขูุฏ ุฌุงฺฏุฐุงุฑ ุจู ุฏู ูุฑุญูู ุชูุณู ูโุดูุฏ:
        </p>
        <ol>
            <li><strong>ุญุงูุช ุดุจุญ (Ghost Mode):</strong> ูุจู ุงุฒ ุชุงุฏ ฺฉุงุฑุจุฑุ ฺฉ ูุณุฎู ูููโุดูุงู ุงุฒ ุตูุญู ุจุงุฒ ุฑู ุฑุชฺฉู ููุงุด ุฏุงุฏู ูโุดูุฏ ุชุง ฺฉุงุฑุจุฑ ููุงุณ ู ุฌูุช ุขู ุฑุง ุจุจูุฏ.</li>
            <li><strong>ููู ุดุฏู (Anchoring):</strong> ุจุง ููุณ ุตูุญู (Tap)ุ ูููุนุช ุตูุญู ุจุงุฒ ุฏุฑ ูุถุง ุณู ุจุนุฏ "ููู" (Freeze) ูโุดูุฏ ู ุฑุชฺฉู ูุงูพุฏุฏ ูโฺฏุฑุฏุฏ. ุงุฒ ุงู ูุญุธู ุจู ุจุนุฏุ ุตูุญู ุจุงุฒ ูุณุจุช ุจู ุฏูุง ูุงูุน ุซุงุจุช ูโูุงูุฏุ ุญุช ุงฺฏุฑ ฺฉุงุฑุจุฑ ุฏุฑ ุงุชุงู ุญุฑฺฉุช ฺฉูุฏ.</li>
        </ol>

        <div class="card">
            <h4>๐ ูุฏุฑุช ููุงุณ (Scale Management)</h4>
            <p>
                ุฏุฑ ููุชูุฑูุง ุณู ุจุนุฏุ ูุงุญุฏูุง ุงูุชุฒุงุน ูุณุชูุฏุ ุงูุง ุฏุฑ AR ูุฑ ูุงุญุฏ ูุนุงุฏู <strong>ฺฉ ูุชุฑ</strong> ุงุณุช. ุตูุญู ุจุงุฒ ถรถ ุงฺฏุฑ ุจุง ููุงุณ ูพุดโูุฑุถ (ฑ) ุฑูุฏุฑ ุดูุฏุ ถ ูุชุฑ ุทูู ุฎูุงูุฏ ุฏุงุดุช!
                <br>
                ุจุฑุง ุญู ุงู ูุดฺฉูุ ฺฉู ุตุญูู ุจุงุฒ ุฏุฑูู ฺฉ ฺฏุฑูู ุจุง ููุงุณ <code>0.04</code> ูุฑุงุฑ ฺฏุฑูุชู ุงุณุช ุชุง ุงูุฏุงุฒู ุขู ุญุฏูุฏ ฒด ุณุงูุชโูุชุฑ ุดูุฏ ู ุจู ุฑุงุญุช ุฑู ฺฉ ูุฒ ููููโุฎูุฑ ุฌุง ุจฺฏุฑุฏ.
            </p>
        </div>

        <h3>ด.ณ. ฺุงูุดโูุง ูู ู ุชุนุงููุงุช</h3>
        <ul>
            <li><strong>ุงูุฒุงูุงุช ุงููุช (HTTPS):</strong> ุทุจู ุงุณุชุงูุฏุงุฑุฏ W3Cุ ูุงุจูุช WebXR ุฏุณุชุฑุณ ุจู ุณูุณูุฑูุง ู ุฏูุฑุจู ุฑุง ุชููุง ุฏุฑ ูุญุทโูุง ุงูู (HTTPS) ูุฑุงูู ูโฺฉูุฏ. ุฏุฑ <code>GameSession.tsx</code> ฺฉ ฺฺฉ ุงููุช ูุฑุงุฑ ุฏุงุฏู ุดุฏู ุชุง ุงฺฏุฑ ฺฉุงุฑุจุฑ ุฑู HTTP ุจุงุดุฏุ ูุดุฏุงุฑ ุฏุฑุงูุช ฺฉูุฏ.</li>
            <li><strong>ุฑูุฏุฑูฺฏ Passthrough:</strong> ูพุณโุฒููู (Background) ุฏุฑ ุญุงูุช AR ุจุงุฏ ุดูุงู (Transparent) ุจุงุดุฏ ุชุง ุชุตูุฑ ุฏูุฑุจู ุฏุณุชฺฏุงู ุฏุฏู ุดูุฏ. ูุง ุจุง ุงุณุชูุงุฏู ุงุฒ ูพุฑุงูพ <code>gl={{ alpha: true }}</code> ุฏุฑ Canvas ู ุบุฑูุนุงู ฺฉุฑุฏู Fog ุฏุฑ ุตุญูู ARุ ุงู ููุถูุน ุฑุง ูุฏุฑุช ฺฉุฑุฏูโุงู.</li>
            <li><strong>ุชุนุงูู ููุณ:</strong> ุฑูุฏุงุฏูุง ฺฉูฺฉ ูุงูุณ ุฏุฑ AR ฺฉุงุฑ ููโฺฉููุฏ. ูุง ุงุฒ ุฑูุฏุงุฏูุง ุงุณุชุงูุฏุงุฑุฏ Pointer Events ุงุณุชูุงุฏู ฺฉุฑุฏูโุงู ฺฉู ุชูุณุท React Three Fiber ุจู Raycasting ุฏุฑ ูุถุง ุณู ุจุนุฏ ุชุฑุฌูู ูโุดููุฏุ ุจูุงุจุฑุงู ฺฉุงุฑุจุฑ ูโุชูุงูุฏ ุจุง ููุณ ฺฉุฑุฏู ฺฏุชโูุง ูุฌุงุฒ ุฑู ุตูุญู ููุจุงูุ ููุฑูโูุง ุฑุง ุฌุงุจุฌุง ฺฉูุฏ.</li>
        </ul>
    </section>
    <!-- SECTION 5: RENDERING & OPTIMIZATION -->
    <section id="section-5">
        <h2>ต. ุฑูุฏุฑูฺฏ ู ุจูููโุณุงุฒ ฺฏุฑุงูฺฉ</h2>
        <p>
            ฺฉ ุงุฒ ุงูููุชโูุง ุงุตู ูพุฑูฺู Quantum Breachุ ุนููฺฉุฑุฏ ุจุงูุง (Performance) ุจูุฏู ุงุณุช. ุฑูุฏุฑ ฺฉุฑุฏู ฺฉ ุตุญูู ุณู ุจุนุฏ ุฏุฑ ูุฑูุฑฺฏุฑ ูุจุ ุจูโูฺู ุฏุฑ ุฏุณุชฺฏุงูโูุง ููุจุงู ุจุง ูุญุฏูุฏุช ุจุงุชุฑ ู ูพุฑุฏุงุฒุดฺฏุฑุ ูุงุฒููุฏ ุชฺฉูฺฉโูุง ุฎุงุต ุงุณุช.
        </p>

        <h3>ต.ฑ. ุชฺฉูฺฉ InstancedMesh</h3>
        <p>
            ุฏุฑ ุตุญูู ูพุณโุฒููู (<code>BackgroundScene.tsx</code>) ู ุฎุทูุท ุดุจฺฉู ุจุงุฒุ ุตุฏูุง ุขุจุฌฺฉุช ููุฏุณ ูุฌูุฏ ุฏุงุฑุฏ. ุงฺฏุฑ ุจุฑุง ูุฑ ฺฉุฏุงู ุงุฒ ุงูโูุง ฺฉ Mesh ุฌุฏุงฺฏุงูู ุงุฌุงุฏ ูโฺฉุฑุฏูุ ุชุนุฏุงุฏ "ูุฑุงุฎูุงูโูุง ุชุฑุณู" (Draw Calls) ุจู ุดุฏุช ุงูุฒุงุด ูโุงูุช ู CPU ฺฏููฺฏุงู ูโุดุฏ.
        </p>
        <p>
            ูุง ุงุฒ ุชฺฉูฺฉ <strong>Geometry Instancing</strong> ุงุณุชูุงุฏู ฺฉุฑุฏูโุงู. ุจุง ุงุณุชูุงุฏู ุงุฒ <code>&lt;instancedMesh /&gt;</code> ุฏุฑ Three.jsุ ุชูุงู ุฐุฑุงุช ูพุณโุฒููู ุชููุง ุจุง <strong>ฺฉ Draw Call</strong> ุจู GPU ุงุฑุณุงู ูโุดููุฏ. ุชุบุฑุงุช ูููุนุชุ ฺุฑุฎุด ู ุฑูฺฏ ูุฑ ุฐุฑู ุงุฒ ุทุฑู ุฏุณุชฺฉุงุฑ ูุณุชูู ูุงุชุฑุณโูุง (Matrix Manipulation) ุฏุฑ ฺฉ ุจุงูุฑ ุงุดุชุฑุงฺฉ ุงูุฌุงู ูโุดูุฏ.
        </p>

        <h3>ต.ฒ. ูุฏุฑุช ูุถุนุช ุจุง Zustand (ุฎุงุฑุฌ ุงุฒ ฺุฑุฎู React)</h3>
        <p>
            ุฏุฑ ุจุฑูุงููโูุง React ูุนูููุ ุชุบุฑ State ุจุงุนุซ ุฑูุฏุฑ ูุฌุฏุฏ (Re-render) ฺฉุงููพูููุชโูุง ูโุดูุฏ. ุฏุฑ ฺฉ ุจุงุฒ ฺฉู ูุถุนุช 60 ุจุงุฑ ุฏุฑ ุซุงูู ุชุบุฑ ูโฺฉูุฏุ ุงู ูฺฉุงูุฒู ุจุณุงุฑ ฺฉูุฏ ุงุณุช.
        </p>
        <p>
            ูุง ุงุฒ ฺฉุชุงุจุฎุงูู <strong>Zustand</strong> ุจุฑุง ูุฏุฑุช ูุถุนุช ุจุงุฒ (<code>gameStore.ts</code>) ุงุณุชูุงุฏู ฺฉุฑุฏูโุงู. ูฺฺฏ ฺฉูุฏ ุขู ุงู ุงุณุช ฺฉู ุงุฌุงุฒู ูโุฏูุฏ ุชุบุฑุงุช ุฑุง ุจุฏูู ุชุญุฑฺฉ ฺุฑุฎู ุฑูุฏุฑ React ุงูุฌุงู ุฏูู ู ฺฉุงููพูููุชโูุง Three.js (ูุงููุฏ <code>useFrame</code>) ูโุชูุงููุฏ ูุณุชููุงู ููุฏุงุฑ ูุญุธูโุง ุฑุง ุงุฒ Store ุจุฎูุงููุฏ (Transient Updates). ุงู ููุถูุน ูฺฏโูุง ูุงุด ุงุฒ Garbage Collection ู React Reconciliation ุฑุง ุญุฐู ฺฉุฑุฏู ุงุณุช.
        </p>

        <h3>ต.ณ. ฺฉุงูุด ุจุงุฑ ุฏุฑ AR</h3>
        <p>
            ููฺฏุงู ฺฉู ุญุงูุช AR ูุนุงู ูโุดูุฏุ ุณุณุชู ุจู ุทูุฑ ููุดููุฏ ุชูุธูุงุช ฺฏุฑุงูฺฉ ุฑุง ุชุบุฑ ูโุฏูุฏ:
        </p>
        <ul>
            <li><strong>ุบุฑูุนุงู ฺฉุฑุฏู Anti-Aliasing (AA):</strong> ุฏุฑ ุตูุญุงุช ููุจุงู ุจุง ุชุฑุงฺฉู ูพฺฉุณู ุจุงูุงุ AA ุณุฑุจุงุฑ ุฒุงุฏ ุฏุงุฑุฏ ู ุชูุงูุช ุจุตุฑ ฺฉู ุงุฌุงุฏ ูโฺฉูุฏ.</li>
            <li><strong>ุญุฐู ูพุณโุฒููู ู ูู (Fog):</strong> ุจุฑุง ุงูฺฉู ุฏูุฑุจู ูุงูุน ุฏุฏู ุดูุฏ ู ูพุฑุฏุงุฒุด GPU ฺฉุงูุด ุงุจุฏ.</li>
            <li><strong>ูุฏุฑุช ุฐุฑุงุช:</strong> ุชุนุฏุงุฏ ุฐุฑุงุช ูุนูู (Sparkles) ุฏุฑ ุญุงูุช AR ุจู ูุตู ฺฉุงูุด ูโุงุจุฏ.</li>
        </ul>
    </section>

    <!-- SECTION 6: CONCLUSION -->
    <section id="section-6">
        <h2>ถ. ูุชุฌูโฺฏุฑ</h2>
        <p>
            ูพุฑูฺู <strong>Quantum Breach</strong> ูููููโุง ุงุฒ ุชูุงูุงโูุง ูุฏุฑู ูุจ ุจุฑุง ุงุฑุงุฆู ุชุฌุฑุจุงุช ุชุนุงูู ูพฺุฏู ุงุณุช. ุจุง ุชุฑฺฉุจ <strong>React</strong> ุจุฑุง ุฑุงุจุท ฺฉุงุฑุจุฑุ <strong>Three.js</strong> ุจุฑุง ฺฏุฑุงูฺฉ ู <strong>Web Workers</strong> ุจุฑุง ูพุฑุฏุงุฒุดโูุง ุณูฺฏูุ ูุง ูููู ุดุฏู ฺฉ ุจุงุฒ ุงุณุชุฑุงุชฺฺฉ ุจุง ููุด ูุตููุน ุณุทุญ ุจุงูุง ุจุณุงุฒู ฺฉู ุจุฏูู ูุงุฒ ุจู ูุตุจุ ุฑู ุทู ูุณุน ุงุฒ ุฏุณุชฺฏุงูโูุง ุงุฌุฑุง ูโุดูุฏ.
        </p>
        <p>
            ุงู ูพุฑูฺู ูุดุงู ูโุฏูุฏ ฺฉู ุงูฺฏูุฑุชูโูุง ฺฉูุงุณฺฉ ุนููู ฺฉุงููพูุชุฑ (ูุงููุฏ Minimax) ููุช ุจุง ุชฺฉููููฺโูุง ููู ูุจ (ูุงููุฏ WebXR ู WebSockets) ุชุฑฺฉุจ ุดููุฏุ ูโุชูุงููุฏ ุชุฌุฑุจุงุช ุฎูู ฺฉููุฏ ฺฉู ูู ุงุฒ ูุธุฑ ูู ุนูู ู ูู ุงุฒ ูุธุฑ ุจุตุฑ ุฌุฐุงุจ ูุณุชูุฏ.
        </p>
    </section>

    <!-- Footer -->
    <footer>
        <p>ุชูุณุนู ุฏุงุฏู ุดุฏู ุชูุณุท ุงูุฑุญุณู ุฎุฏุง | ูุณุชูุฏุณุงุฒ ุฎูุฏฺฉุงุฑ ุดุฏู ุชูุณุท ููุด ูุตููุน</p>
        <p style="direction: ltr; font-family: monospace;">Build v1.0.0 | Engine: React + Three.js</p>
    </footer>

</div> <!-- End of Container -->

</body>
</html>
--- END OF FILE: report.html ---


--- START OF FILE: tailwind.config.js ---
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        'cyber-black': '#050505',
        'cyber-gray': '#1a1a1a',
        'neon-blue': '#00f3ff',
        'neon-pink': '#ff0055',
        'neon-green': '#00ff41',
        'neon-yellow': '#fcee0a',
      },
      boxShadow: {
        'neon': '0 0 10px rgba(0, 243, 255, 0.7), 0 0 20px rgba(0, 243, 255, 0.5)',
      }
    },
  },
  plugins: [],
}
--- END OF FILE: tailwind.config.js ---


--- START OF FILE: tsconfig.app.json ---
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src", "tailwind.config.js"]
}

--- END OF FILE: tsconfig.app.json ---


--- START OF FILE: tsconfig.json ---
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

--- END OF FILE: tsconfig.json ---


--- START OF FILE: tsconfig.node.json ---
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}

--- END OF FILE: tsconfig.node.json ---


--- START OF FILE: vite.config.ts ---
// vite.config.ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import basicSsl from '@vitejs/plugin-basic-ssl'
import { resolve } from 'path'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react(), basicSsl()],
  
  server: {
    host: true, 
    // PROXY CONFIGURATION
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        changeOrigin: true,
        secure: false,
      },
      '/socket.io': {
        target: 'http://localhost:3000',
        ws: true,
        changeOrigin: true,
        secure: false
      }
    }
  },

  resolve: {
    alias: {
      'three': resolve(__dirname, './node_modules/three')
    }
  },

  // PERFORMANCE & BUILD OPTIMIZATION
  build: {
    target: 'esnext', // Modern JS (smaller bundles, faster parsing on client)
    chunkSizeWarningLimit: 1000, // Suppress warnings for large 3D engine chunks
    
    rollupOptions: {
      output: {
        // Optimization #26: Hashed filenames for aggressive long-term caching
        entryFileNames: 'assets/[name].[hash].js',
        chunkFileNames: 'assets/[name].[hash].js',
        assetFileNames: 'assets/[name].[hash].[ext]',

        // Optimization #6: Granular Chunking
        manualChunks: {
          // 1. Core React Vendor (Stable, rarely changes)
          'react-vendor': ['react', 'react-dom', 'react-router-dom', 'zustand'],
          
          // 2. UI Vendor (Animations & Utilities)
          'ui-vendor': ['framer-motion', 'clsx', 'tailwind-merge'],
          
          // 3. 3D Engine Core (The heaviest part)
          'three-core': ['three', '@react-three/fiber', '@react-three/drei'],
          
          // 4. XR Specific (Isolated so non-AR users don't parse it)
          'three-xr': ['@react-three/xr'],
          
          // 5. Networking (Isolated for offline players)
          'networking': ['socket.io-client', 'uuid']
        }
      }
    }
  }
})
--- END OF FILE: vite.config.ts ---


--- START OF FILE: server\index.js ---
// server/index.js
import express from 'express';
import cors from 'cors';
import { createServer } from 'http';
import { Server } from 'socket.io';

// --- CONFIG ---
const PORT = 3000;
const GRID_SIZE = 6;
const TOTAL_CELLS = 36;
const MOVE_RATE_LIMIT_MS = 200; // Max 5 moves per second

// --- APP SETUP ---
const app = express();
app.use(cors({ origin: "*" })); // In production, replace "*" with your domain
app.use(express.json());

const httpServer = createServer(app);
const io = new Server(httpServer, {
  cors: { origin: "*", methods: ["GET", "POST"] },
  pingTimeout: 10000,
});

// --- STATE MANAGEMENT ---
const rooms = new Map();
const rateLimiter = new Map(); // Tracks last move time per socket

// --- HELPER: GAME LOGIC ---

const createBoard = () => Array.from({ length: TOTAL_CELLS }, (_, i) => ({
  id: i,
  x: Math.floor(i / GRID_SIZE),
  y: i % GRID_SIZE,
  owner: null,
  status: null, 
  fluxOwner: null
}));

// OPTIMIZATION #11: Strict Validation
const validateMove = (board, nodeId, gate, player) => {
  // 1. Type Safety
  if (typeof nodeId !== 'number' || !Number.isInteger(nodeId)) return false;
  if (typeof gate !== 'string') return false;

  // 2. Bounds Check
  if (nodeId < 0 || nodeId >= TOTAL_CELLS) return false;

  // 3. Gate Validity
  if (!['Z', 'X', 'H'].includes(gate)) return false;

  // 4. Game Rule: Placement must be on empty cell
  const node = board[nodeId];
  if (!node || node.status !== null) return false; 

  return true;
};

const applyServerMove = (board, nodeId, gate, player) => {
  const node = board[nodeId];
  // Basic state update for server authority
  // Detailed physics are deterministic via Seed on client
  if (gate === 'Z') {
    node.status = 'LOCKED';
    node.owner = player;
  } else if (gate === 'X') {
    node.status = 'STABLE';
    node.owner = player;
  } else if (gate === 'H') {
    node.status = 'FLUX';
    node.owner = null;
    node.fluxOwner = player;
  }
  return board;
};

// --- SOCKET HANDLERS ---

io.on('connection', (socket) => {
  console.log(`๐ [${socket.id}] Connected`);

  // --- JOIN ROOM ---
  socket.on('join_room', (rawRoomId) => {
    // Sanitization
    if (!rawRoomId || typeof rawRoomId !== 'string') return;
    const roomId = rawRoomId.trim().toUpperCase().slice(0, 12);

    let room = rooms.get(roomId);

    // Create Room if not exists
    if (!room) {
      room = { 
        id: roomId,
        blue: null, 
        red: null, 
        board: createBoard(), 
        turn: 'blue', 
        status: 'waiting',
        lastMoveTime: Date.now()
      };
      rooms.set(roomId, room);
    }

    // Full Room Check
    if (room.blue && room.red) {
      socket.emit('error', 'Room is full.');
      return;
    }

    // Assign Role
    let role = 'spectator';
    if (!room.blue) { 
      room.blue = socket.id; 
      role = 'blue'; 
    } else if (!room.red) { 
      room.red = socket.id; 
      role = 'red'; 
    }

    socket.join(roomId);
    socket.roomId = roomId;
    socket.role = role;
    
    socket.emit('role_assigned', role);
    console.log(`๐ค [${socket.id}] Joined ${roomId} as ${role}`);

    // Start Game
    if (room.blue && room.red) {
      room.status = 'playing';
      io.to(roomId).emit('game_start', { startTurn: 'blue' });
      console.log(`โ๏ธ Game Started: ${roomId}`);
    }
  });

  // --- MAKE MOVE ---
  socket.on('make_move', (data) => {
    // OPTIMIZATION #12: Rate Limiting
    const now = Date.now();
    const lastRequest = rateLimiter.get(socket.id) || 0;
    if (now - lastRequest < MOVE_RATE_LIMIT_MS) {
        // Silently ignore spam
        return;
    }
    rateLimiter.set(socket.id, now);

    const { roomId, nodeId, gate, seed } = data;
    const room = rooms.get(roomId);

    if (!room) return;
    if (room.status !== 'playing') return;
    
    // SECURITY: Turn Order
    if (room.turn !== socket.role) {
      console.warn(`โ๏ธ [${socket.id}] Attempted move out of turn!`);
      return; 
    }

    // SECURITY: Validation
    if (!validateMove(room.board, nodeId, gate, socket.role)) {
      console.warn(`โ๏ธ [${socket.id}] Attempted invalid move on cell ${nodeId}`);
      return; 
    }

    // Update Server State
    room.board = applyServerMove(room.board, nodeId, gate, socket.role);
    
    // Switch Turn
    room.turn = room.turn === 'blue' ? 'red' : 'blue';
    room.lastMoveTime = Date.now();

    // Broadcast
    socket.to(roomId).emit('opponent_move', {
      nodeId,
      gate,
      seed // Relay deterministic seed
    });
  });

  // --- DISCONNECT ---
  socket.on('disconnect', () => {
    rateLimiter.delete(socket.id); // Cleanup rate limiter
    
    if (socket.roomId) {
      const room = rooms.get(socket.roomId);
      if (room) {
        console.log(`๐ [${socket.id}] Left ${socket.roomId}`);
        io.to(socket.roomId).emit('player_left');
        
        // Cleanup room if empty
        if ((room.blue === socket.id && !room.red) || (room.red === socket.id && !room.blue)) {
             rooms.delete(socket.roomId);
        } else {
            // Remove player from slot so they can potentially reconnect or someone else can join
            if (room.blue === socket.id) room.blue = null;
            if (room.red === socket.id) room.red = null;
        }
      }
    }
  });
});

// --- API ---
app.get('/api/rooms', (req, res) => {
  const list = [];
  rooms.forEach((r) => {
    if (r.status === 'waiting') {
      list.push({ id: r.id, players: r.blue ? 1 : 0 });
    }
  });
  res.json(list);
});

httpServer.listen(PORT, '0.0.0.0', () => {
  console.log(`๐ Secure Quantum Server running on port ${PORT}`);
});
--- END OF FILE: server\index.js ---


--- START OF FILE: src\App.tsx ---
// src/App.tsx
import React, { Suspense, lazy, Component, type ReactNode } from 'react';
import { BrowserRouter, Routes, Route, useLocation } from 'react-router-dom';
import { Canvas } from '@react-three/fiber'; // <--- IMPORT ADDED
import { useGameStore } from './store/gameStore';
import { Loader } from './components/dom/ui/Loader';
import BackgroundScene from './components/canvas/BackgroundScene';

// --- 1. EAGER LOADING ---
import Home from './pages/Home';

// --- 2. LAZY LOADING ---
const OfflineSetup = lazy(() => import('./pages/OfflineSetup'));
const Lobby = lazy(() => import('./pages/Lobby'));
const GameSession = lazy(() => import('./pages/GameSession'));
const GameGuide = lazy(() => import('./pages/GameGuide'));
const MinimaxInfo = lazy(() => import('./pages/MinimaxInfo'));

// --- 3. ERROR BOUNDARY ---
interface ErrorProps { children: ReactNode }
interface ErrorState { hasError: boolean; error: Error | null }

class ErrorBoundary extends Component<ErrorProps, ErrorState> {
  constructor(props: ErrorProps) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="fixed inset-0 z-[9999] bg-black flex flex-col items-center justify-center text-red-500 font-mono p-6 text-center">
          <h1 className="text-4xl font-black mb-4 tracking-widest border-b border-red-500 pb-2">SYSTEM FAILURE</h1>
          <p className="mb-8 text-sm opacity-80 max-w-md">
            CRITICAL ERROR DETECTED IN QUANTUM CORE.<br/>
            {this.state.error?.message}
          </p>
          <button 
            onClick={() => window.location.reload()}
            className="px-8 py-4 border border-red-500 hover:bg-red-500 hover:text-black font-bold tracking-[0.2em] transition-all rounded"
          >
            // REBOOT SYSTEM
          </button>
        </div>
      );
    }
    return this.props.children;
  }
}

// --- 4. GLOBAL COMPONENTS ---

const GlobalLoaderWrapper = () => {
  const isLoading = useGameStore(state => state.isLoading);
  if (isLoading) return <Loader message="PROCESSING COMMAND" />;
  return null;
};

const GameLayout = ({ children }: { children: React.ReactNode }) => {
  const location = useLocation();
  const isGameSession = location.pathname === '/game';

  return (
    <>
      {/* GLOBAL BACKGROUND (Only visible outside of the game session) */}
      {!isGameSession && (
        <div className="fixed inset-0 z-0 pointer-events-none">
          {/* FIX: Wrapped in Canvas because BackgroundScene is now just a mesh */}
          <Canvas 
            camera={{ position: [0, 0, 30], fov: 60 }}
            dpr={[1, 1.5]}
            gl={{ 
              powerPreference: "low-power", 
              antialias: false, 
              depth: false, 
              stencil: false 
            }}
          >
             <BackgroundScene speed={0.4} autoShift={true} />
          </Canvas>
          
          {/* Global Scanline Overlay */}
          <div className="absolute inset-0 bg-[url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0IiBoZWlnaHQ9IjQiPgo8cmVjdCB3aWR0aD0iNCIgaGVpZ2h0PSI0IiBmaWxsPSIjMDAwMDAwIi8+CjxyZWN0IHdpZHRoPSI0IiBoZWlnaHQ9IjEiIGZpbGw9InJnYmEoMCwgMjQzLCAyNTUsIDAuMSkiLz4KPC9zdmc+')] opacity-20"></div>
        </div>
      )}
      
      {children}
    </>
  );
};

// --- MAIN APP ---

function App() {
  return (
    <ErrorBoundary>
      <BrowserRouter>
        <GlobalLoaderWrapper />
        
        <GameLayout>
          <Suspense fallback={<Loader message="LOADING MODULES" />}>
            <Routes>
              <Route path="/" element={<Home />} />
              <Route path="/setup" element={<OfflineSetup />} />
              <Route path="/lobby" element={<Lobby />} />
              <Route path="/game" element={<GameSession />} />
              <Route path="/guide" element={<GameGuide />} />
              <Route path="/ai-logic" element={<MinimaxInfo />} />
            </Routes>
          </Suspense>
        </GameLayout>
        
      </BrowserRouter>
    </ErrorBoundary>
  );
}

export default App;
--- END OF FILE: src\App.tsx ---


--- START OF FILE: src\index.css ---
@tailwind base;
@tailwind components;
@tailwind utilities;

/* GLOBAL RESET */
html, body, #root {
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: hidden; 
  background-color: #050505; 
  color: #c0c0c0;
  font-family: 'Courier New', Courier, monospace; 
  
  /* Disable selection for app-like feel */
  -webkit-user-select: none; 
  user-select: none; 
  
  /* Prevent pull-to-refresh on mobile */
  overscroll-behavior: none;
}

/* 3D CANVAS OPTIMIZATION */
canvas {
  /* Critical for mobile game control */
  touch-action: none; 
  outline: none;
  -webkit-tap-highlight-color: transparent;
}

/* UI ELEMENTS */
button, input, a {
  /* Re-enable interaction for UI */
  pointer-events: auto;
  touch-action: manipulation;
}

/* CUSTOM SCROLLBAR */
::-webkit-scrollbar {
  width: 6px;
}
::-webkit-scrollbar-track {
  background: #050505;
}
::-webkit-scrollbar-thumb {
  background: #1a1a1a;
  border: 1px solid #00f3ff;
  border-radius: 4px;
}
--- END OF FILE: src\index.css ---


--- START OF FILE: src\main.tsx ---
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './index.css' // <--- THIS IMPORT IS MISSING!

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
--- END OF FILE: src\main.tsx ---


--- START OF FILE: src\components\canvas\BackgroundScene.tsx ---
// src/components/canvas/BackgroundScene.tsx
import { useRef, useLayoutEffect, useMemo } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { GeometryManager } from '../../engine/core/GeometryManager';

interface BackgroundProps {
  speed?: number; 
  autoShift?: boolean; 
}

const isMobile = /iPhone|iPad|Android/i.test(navigator.userAgent);
const COUNT = isMobile ? 80 : 200; 

const DUMMY = new THREE.Object3D();
const COLOR_DUMMY = new THREE.Color();
const COL_GREEN = new THREE.Color('#00ff41');
const COL_BLUE = new THREE.Color('#00f3ff');
const COL_RED = new THREE.Color('#ff0055');

const COLOR_LUT = new Array(101).fill(null).map((_, i) => 
  new THREE.Color().lerpColors(COL_BLUE, COL_RED, i / 100)
);

const BackgroundScene = ({ speed = 1, autoShift = false }: BackgroundProps) => {
  const meshRef = useRef<THREE.InstancedMesh>(null);
  const currentScales = useRef(new Float32Array(COUNT).fill(0));

  const geometry = useMemo(() => 
    GeometryManager.getGeometry('bg-icosahedron', () => new THREE.IcosahedronGeometry(0.6, 0)), 
  []);

  const material = useMemo(() => 
    GeometryManager.getMaterial('bg-wireframe', () => new THREE.MeshBasicMaterial({ 
      wireframe: true, 
      transparent: true, 
      opacity: 0.4 
    })), 
  []);

  const { positions, randoms } = useMemo(() => {
    const pos = new Float32Array(COUNT * 3);
    const rnd = new Float32Array(COUNT * 3); 

    for (let i = 0; i < COUNT; i++) {
      pos[i * 3] = (Math.random() - 0.5) * 60;     
      pos[i * 3 + 1] = (Math.random() - 0.5) * 60; 
      pos[i * 3 + 2] = (Math.random() - 0.5) * 30; 

      rnd[i * 3] = Math.random();
      rnd[i * 3 + 1] = Math.random();
      rnd[i * 3 + 2] = Math.random();
    }
    return { positions: pos, randoms: rnd };
  }, []);

  useLayoutEffect(() => {
    if (!meshRef.current) return;

    const colorArray = new Float32Array(COUNT * 3);
    for (let i = 0; i < COUNT; i++) {
      colorArray[i * 3] = COL_BLUE.r;
      colorArray[i * 3 + 1] = COL_BLUE.g;
      colorArray[i * 3 + 2] = COL_BLUE.b;
    }
    
    meshRef.current.instanceColor = new THREE.InstancedBufferAttribute(colorArray, 3);

    DUMMY.scale.set(0, 0, 0); 
    for (let i = 0; i < COUNT; i++) {
      DUMMY.position.set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]);
      DUMMY.updateMatrix();
      meshRef.current.setMatrixAt(i, DUMMY.matrix);
    }
    
    meshRef.current.instanceMatrix.needsUpdate = true;
  }, [positions]);

  useFrame((state, delta) => {
    if (!meshRef.current || !meshRef.current.instanceColor) return;

    const time = state.clock.getElapsedTime();
    const safeDelta = Math.min(delta, 0.1); 

    let lutIndex = 0; 
    let activeThreshold = isMobile ? 60 : 100;

    if (autoShift) {
        const t = time * 0.2;
        const sine = Math.sin(t);
        
        if (sine > 0.3) {
            lutIndex = 0;
            activeThreshold = isMobile ? 70 : 140; 
        } else if (sine < -0.3) {
            lutIndex = 100;
            activeThreshold = isMobile ? 80 : 200; 
        } else {
            lutIndex = -1; 
            activeThreshold = isMobile ? 40 : 60;  
        }
    } else {
        const normalizedSpeed = Math.min(speed, 10);
        activeThreshold = (isMobile ? 40 : 60) + (normalizedSpeed / 10) * (isMobile ? 60 : 140);
        
        if (speed <= 2.5) { lutIndex = -1; }
        else if (speed <= 6.5) { lutIndex = 0; }
        else { lutIndex = 100; }
    }

    let needsMatrixUpdate = false;
    let needsColorUpdate = false;

    for (let i = 0; i < COUNT; i++) {
      const ix = i * 3;
      
      const isVisible = i < activeThreshold;
      const targetScale = isVisible ? (1 + Math.sin(time * 2 + i) * 0.2) : 0;
      const diff = targetScale - currentScales.current[i];
      
      if (Math.abs(diff) > 0.001) {
        currentScales.current[i] += diff * safeDelta * 3.0;
        needsMatrixUpdate = true;
      }

      if (currentScales.current[i] < 0.01) {
          if (DUMMY.scale.x !== 0) { 
            DUMMY.scale.setScalar(0);
            DUMMY.updateMatrix();
            meshRef.current.setMatrixAt(i, DUMMY.matrix);
            needsMatrixUpdate = true;
          }
          continue; 
      }

      const rndSpeed = randoms[ix] * 0.5 + 0.5;
      const t = time * ((speed * 0.1) + 0.2) * rndSpeed + (randoms[ix + 2] * Math.PI * 2);

      DUMMY.position.set(
        positions[ix] + Math.sin(t * 0.3) * 2,
        positions[ix + 1] + Math.cos(t * 0.2) * 2,
        positions[ix + 2] + Math.sin(t * 0.1) * 1
      );
      
      DUMMY.rotation.x = time * rndSpeed * 0.5;
      DUMMY.rotation.y = time * rndSpeed * 0.3;
      DUMMY.scale.setScalar(currentScales.current[i]);
      DUMMY.updateMatrix();
      meshRef.current.setMatrixAt(i, DUMMY.matrix);
      needsMatrixUpdate = true;

      if (lutIndex === -1) {
         meshRef.current.getColorAt(i, COLOR_DUMMY);
         if (Math.abs(COLOR_DUMMY.g - COL_GREEN.g) > 0.01) {
            COLOR_DUMMY.lerp(COL_GREEN, safeDelta * 2);
            meshRef.current.setColorAt(i, COLOR_DUMMY);
            needsColorUpdate = true;
         }
      } else {
         meshRef.current.getColorAt(i, COLOR_DUMMY);
         const target = COLOR_LUT[lutIndex];
         
         if (Math.abs(COLOR_DUMMY.r - target.r) > 0.01) {
            COLOR_DUMMY.lerp(target, safeDelta * 2);
            meshRef.current.setColorAt(i, COLOR_DUMMY);
            needsColorUpdate = true;
         }
      }
    }

    if (needsMatrixUpdate) meshRef.current.instanceMatrix.needsUpdate = true;
    if (needsColorUpdate) meshRef.current.instanceColor.needsUpdate = true;
  });

  return (
    <instancedMesh 
      ref={meshRef} 
      args={[geometry, material, COUNT]} 
      renderOrder={-1}
    />
  );
};

export default BackgroundScene;
--- END OF FILE: src\components\canvas\BackgroundScene.tsx ---


--- START OF FILE: src\components\canvas\ar\ARControls.tsx ---
// src/components/canvas/ar/ARPlacement.tsx
import { useRef, useMemo } from 'react';
import { useXRHitTest } from '@react-three/xr'; 
import { Ring, Circle } from '@react-three/drei';
import * as THREE from 'three';
import { useGameStore } from '../../../store/gameStore';

interface ARPlacementProps {
  children: React.ReactNode;
}

export const ARPlacement = ({ children }: ARPlacementProps) => {
  const reticleRef = useRef<THREE.Group>(null);
  const contentRef = useRef<THREE.Group>(null);
  
  // CONNECT TO STORE
  const isARPlaced = useGameStore(state => state.isARPlaced);
  const setARPlaced = useGameStore(state => state.setARPlaced);
  const arScale = useGameStore(state => state.arScale); // This is locked at 0.04

  const hitMatrix = useMemo(() => new THREE.Matrix4(), []);

  // 1. HIT TEST (Scanning for floor)
  useXRHitTest((results, getWorldMatrix) => {
    // If we are already placed (LOCKED), stop scanning to save resources
    if (isARPlaced) {
       if (reticleRef.current) reticleRef.current.visible = false;
       return;
    }

    if (results.length > 0) {
      const success = getWorldMatrix(hitMatrix, results[0]);

      if (success && reticleRef.current && contentRef.current) {
        reticleRef.current.visible = true;
        
        // Decompose matrix to get position/rotation
        hitMatrix.decompose(
          reticleRef.current.position,
          reticleRef.current.quaternion,
          reticleRef.current.scale
        );

        // Move the Game Board (Ghost Mode) to follow reticle
        contentRef.current.position.copy(reticleRef.current.position);
        contentRef.current.quaternion.copy(reticleRef.current.quaternion);
      }
    } else {
        // Hide reticle if no floor found
        if (reticleRef.current) reticleRef.current.visible = false;
    }
  }, 'viewer'); 

  // 2. TAP LISTENER
  const handleTap = (e: any) => {
    if (isARPlaced) return; // Already locked
    e.stopPropagation(); // Prevent clicking things behind it
    setARPlaced(true); // LOCK THE BOARD
  };

  return (
    <>
      {/* Visual Reticle (Green Ring) - Only shows when NOT placed */}
      {!isARPlaced && (
        <group ref={reticleRef} visible={false}>
            <group rotation={[-Math.PI / 2, 0, 0]}>
                <Ring args={[0.15, 0.2, 32]}>
                    <meshBasicMaterial color="#00ff41" transparent opacity={0.8} />
                </Ring>
                <Circle args={[0.05, 32]}>
                    <meshBasicMaterial color="#00ff41" />
                </Circle>
            </group>
        </group>
      )}

      {/* Invisible Floor Plane - Catches the Tap */}
      {!isARPlaced && (
         <mesh rotation={[-Math.PI/2, 0, 0]} position={[0,0,0]} onClick={handleTap}>
            <planeGeometry args={[100, 100]} />
            <meshBasicMaterial transparent opacity={0} />
         </mesh>
      )}

      {/* The Actual Game Board */}
      <group ref={contentRef} visible={true} scale={[arScale, arScale, arScale]}>
         {children}
      </group>
    </>
  );
};
--- END OF FILE: src\components\canvas\ar\ARControls.tsx ---


--- START OF FILE: src\components\canvas\ar\ARPlacement.tsx ---
// src/components/canvas/ar/ARPlacement.tsx
import { useRef, useMemo } from 'react';
import { useXRHitTest } from '@react-three/xr'; 
import { Ring, Circle } from '@react-three/drei';
import * as THREE from 'three';
import { useGameStore } from '../../../store/gameStore';

interface ARPlacementProps {
  children: React.ReactNode;
}

export const ARPlacement = ({ children }: ARPlacementProps) => {
  const reticleRef = useRef<THREE.Group>(null);
  const contentRef = useRef<THREE.Group>(null);
  
  const isARPlaced = useGameStore(state => state.isARPlaced);
  const setARPlaced = useGameStore(state => state.setARPlaced);
  const arScale = useGameStore(state => state.arScale); 

  const hitMatrix = useMemo(() => new THREE.Matrix4(), []);

  useXRHitTest((results, getWorldMatrix) => {
    // If already placed, stop updating position to save resources
    if (isARPlaced) return;

    if (results.length > 0) {
      const success = getWorldMatrix(hitMatrix, results[0]);

      if (success) {
        // 1. Update Reticle Position
        if (reticleRef.current) {
            reticleRef.current.visible = true;
            hitMatrix.decompose(
              reticleRef.current.position,
              reticleRef.current.quaternion,
              reticleRef.current.scale
            );
        }

        // 2. Update Ghost Board Position (So you see what you're placing)
        if (contentRef.current) {
            contentRef.current.visible = true; // Make sure it's visible during placement
            contentRef.current.position.copy(reticleRef.current!.position);
            contentRef.current.quaternion.copy(reticleRef.current!.quaternion);
        }
      }
    } else {
        if (reticleRef.current) reticleRef.current.visible = false;
        // Optionally hide content if tracking is lost, to prevent floating weirdness
        if (contentRef.current && !isARPlaced) contentRef.current.visible = false;
    }
  }, 'viewer'); 

  const handleTap = (e: any) => {
    if (isARPlaced) return;
    e.stopPropagation();
    
    // Lock the board
    setARPlaced(true);
    
    // Hide reticle
    if (reticleRef.current) reticleRef.current.visible = false;
  };

  return (
    <>
      {/* 1. RETICLE (Green Ring) */}
      <group ref={reticleRef} visible={false}>
            <group rotation={[-Math.PI / 2, 0, 0]}>
                <Ring args={[0.08, 0.1, 32]}>
                    <meshBasicMaterial color="#00ff41" transparent opacity={0.8} depthTest={false} />
                </Ring>
                <Circle args={[0.02, 32]}>
                    <meshBasicMaterial color="#00ff41" depthTest={false} />
                </Circle>
            </group>
      </group>

      {/* 2. TAP LISTENER (Floor Plane) */}
      {!isARPlaced && (
         <mesh rotation={[-Math.PI/2, 0, 0]} position={[0,0,0]} onClick={handleTap}>
            <planeGeometry args={[100, 100]} />
            <meshBasicMaterial transparent opacity={0} />
         </mesh>
      )}

      {/* 3. CONTENT (The Game Board) */}
      {/* Start invisible, hit test will make it visible */}
      <group ref={contentRef} visible={false} scale={[arScale, arScale, arScale]}>
         {children}
      </group>
    </>
  );
};
--- END OF FILE: src\components\canvas\ar\ARPlacement.tsx ---


--- START OF FILE: src\components\canvas\board\QuantumBoard.tsx ---
// src/components/canvas/board/QuantumBoard.tsx
import { useRef, useLayoutEffect, useMemo, useState, useEffect } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { useBoard, useGameStore } from '../../../store/gameStore';
import { QubitNode } from './QubitNode';
import { HolographicHUD } from '../ui/HolographicHUD'; 

// --- CONSTANTS & GEOMETRIES ---
const GRID_SIZE = 6;
const CELL_SPACING = 1.1;
const BOARD_WIDTH = GRID_SIZE * CELL_SPACING;
const OFFSET = BOARD_WIDTH / 2 - (CELL_SPACING / 2); 

// Geometries created once globally
const CHASSIS_GEO = new THREE.BoxGeometry(BOARD_WIDTH + 0.8, 0.4, BOARD_WIDTH + 0.8);
const VENT_GEO = new THREE.BoxGeometry(BOARD_WIDTH + 1.0, 0.15, BOARD_WIDTH + 1.0);
const GLASS_GEO = new THREE.BoxGeometry(BOARD_WIDTH + 0.2, 0.05, BOARD_WIDTH + 0.2);
const BOLT_GEO = new THREE.CylinderGeometry(0.15, 0.15, 0.3, 16);
const TRACE_GEO = new THREE.BoxGeometry(0.35, 0.01, 0.04);
const BEAM_GEO = new THREE.CylinderGeometry(0.04, 0.04, 0.6, 12);

// Materials created once globally
const MAT_STEEL = new THREE.MeshStandardMaterial({ 
  color: "#555555", roughness: 0.4, metalness: 0.8, emissive: "#111122", emissiveIntensity: 0.2
});
const MAT_WIRE_BRIGHT = new THREE.MeshBasicMaterial({
    color: "#00f3ff", wireframe: true, transparent: true, opacity: 0.3
});
const MAT_GLOW_STRIP = new THREE.MeshBasicMaterial({ 
  color: "#00f3ff", transparent: true, opacity: 0.8 
});
const MAT_GLASS = new THREE.MeshStandardMaterial({ 
  color: "#88ccff", roughness: 0.2, metalness: 0.1, transparent: true, opacity: 0.6, side: THREE.DoubleSide
});
const MAT_CHROME = new THREE.MeshStandardMaterial({ 
  color: "#ffffff", roughness: 0.2, metalness: 0.9 
});

const COL_BLUE = new THREE.Color('#00f3ff');
const COL_RED = new THREE.Color('#ff0055');
const COL_CRITICAL = new THREE.Color('#ff0055'); 

export const QuantumBoard = () => {
  // OPTIMIZATION #8: Granular Selectors
  const board = useBoard();
  const isARMode = useGameStore(s => s.isARMode);
  const instability = useGameStore(s => s.instability);
  const currentPlayer = useGameStore(s => s.currentPlayer);

  const traceRef = useRef<THREE.InstancedMesh>(null);
  const traceMatRef = useRef<THREE.MeshBasicMaterial>(null);
  const lightRef = useRef<THREE.PointLight>(null);
  
  // Local material instance for beams (dynamic color)
  const [beamMat] = useState(() => new THREE.MeshBasicMaterial({
    color: "#00f3ff", transparent: true, opacity: 0.8, toneMapped: false
  }));

  const targetColorTrace = useMemo(() => new THREE.Color(), []);
  const targetColorLight = useMemo(() => new THREE.Color(), []);
  
  // OPTIMIZATION #9: Frame Throttling
  // We only update heavy visual effects every ~30ms (30fps) instead of 16ms (60fps)
  let lastUpdate = 0;

  useFrame((state, delta) => {
    const time = state.clock.getElapsedTime();
    if (time - lastUpdate < 0.033) return; // Skip frame if too soon
    lastUpdate = time;

    // 1. ENTROPY LOGIC (Grid Lines & Beacons)
    const t = instability / 100;
    targetColorTrace.lerpColors(COL_BLUE, COL_CRITICAL, t);
    
    // Smooth Lerp using delta
    if (traceMatRef.current) traceMatRef.current.color.lerp(targetColorTrace, delta * 5); // Increased speed to compensate for throttle
    beamMat.color.lerp(targetColorTrace, delta * 5);

    // 2. TURN LOGIC (Center Light)
    const turnColor = currentPlayer === 'blue' ? COL_BLUE : COL_RED;
    targetColorLight.lerp(turnColor, delta * 3);
    
    if (lightRef.current) {
        lightRef.current.color.copy(targetColorLight);
        lightRef.current.intensity = 6 + Math.sin(time * 3) * 1.5;
    }
  });

  // OPTIMIZATION #2: Cleanup on Unmount
  useEffect(() => {
    return () => {
      beamMat.dispose();
      // Global mats don't need disposal here as they persist,
      // but if we created local geometries, we would dispose them here.
    };
  }, [beamMat]);

  useLayoutEffect(() => {
    if (!traceRef.current) return;
    const temp = new THREE.Object3D();
    let idx = 0;
    const toPos = (i: number) => (i * CELL_SPACING) - OFFSET;

    for (let x = 0; x < GRID_SIZE; x++) {
        for (let z = 0; z < GRID_SIZE; z++) {
            const posX = toPos(x);
            const posZ = toPos(z);
            if (x < GRID_SIZE - 1) {
                const midX = (posX + toPos(x + 1)) / 2;
                temp.position.set(midX, 0, posZ);
                temp.rotation.set(0, 0, 0); 
                temp.updateMatrix();
                traceRef.current.setMatrixAt(idx++, temp.matrix);
            }
            if (z < GRID_SIZE - 1) {
                const midZ = (posZ + toPos(z + 1)) / 2;
                temp.position.set(posX, 0, midZ);
                temp.rotation.set(0, Math.PI / 2, 0); 
                temp.updateMatrix();
                traceRef.current.setMatrixAt(idx++, temp.matrix);
            }
            if (z === 0) { temp.position.set(posX, 0, posZ - 0.5); temp.rotation.set(0, Math.PI/2, 0); temp.updateMatrix(); traceRef.current.setMatrixAt(idx++, temp.matrix); }
            if (z === GRID_SIZE - 1) { temp.position.set(posX, 0, posZ + 0.5); temp.rotation.set(0, Math.PI/2, 0); temp.updateMatrix(); traceRef.current.setMatrixAt(idx++, temp.matrix); }
            if (x === 0) { temp.position.set(posX - 0.5, 0, posZ); temp.rotation.set(0, 0, 0); temp.updateMatrix(); traceRef.current.setMatrixAt(idx++, temp.matrix); }
            if (x === GRID_SIZE - 1) { temp.position.set(posX + 0.5, 0, posZ); temp.rotation.set(0, 0, 0); temp.updateMatrix(); traceRef.current.setMatrixAt(idx++, temp.matrix); }
        }
    }
    traceRef.current.instanceMatrix.needsUpdate = true;
  }, []);

  return (
    <group position={[0, 0, 0]}>
      
      {/* LEVEL 1: CELLS (Centered) */}
      <group position={[-OFFSET, 0, -OFFSET]}>
        {board.map((qubit, i) => (
          <QubitNode key={qubit.id} data={qubit} index={i} />
        ))}
      </group>

      {/* LEVEL 2: THE PLATFORM */}
      <group position={[0, -0.85, 0]}>
         <pointLight ref={lightRef} position={[0, 0.5, 0]} intensity={3} color="#00f3ff" distance={10} />
         
         <mesh geometry={GLASS_GEO} material={MAT_GLASS} position={[0, 0.25, 0]} />
         
         <instancedMesh ref={traceRef} args={[TRACE_GEO, undefined, 100]} position={[0, 0.28, 0]}>
            <meshBasicMaterial ref={traceMatRef} toneMapped={false} color="#00f3ff" />
         </instancedMesh>
         
         <mesh geometry={VENT_GEO} material={MAT_GLOW_STRIP} position={[0, 0.1, 0]} scale={[0.98, 0.2, 0.98]} />
         
         <group position={[0, -0.2, 0]}>
            <mesh geometry={CHASSIS_GEO} material={MAT_STEEL} />
            <mesh geometry={CHASSIS_GEO} material={MAT_WIRE_BRIGHT} scale={1.005} />
         </group>
         
         <group position={[0, 0.1, 0]}>
            <mesh geometry={VENT_GEO} material={MAT_STEEL} />
            <mesh geometry={VENT_GEO} material={MAT_WIRE_BRIGHT} scale={1.005} />
         </group>

         <group position={[0, 0.2, 0]}>
            {[1, -1].map(x => [1, -1].map(z => (
                <group key={`${x}-${z}`} position={[x * (BOARD_WIDTH/2 + 0.3), 0, z * (BOARD_WIDTH/2 + 0.3)]}>
                    <mesh geometry={BOLT_GEO} material={MAT_CHROME} />
                    <mesh position={[x * -0.2, -0.1, z * -0.2]}>
                        <boxGeometry args={[0.06, 0.06, 0.06]} />
                        <meshBasicMaterial color="#ff0000" toneMapped={false} />
                    </mesh>
                    <mesh geometry={BEAM_GEO} material={beamMat} position={[0, 0.4, 0]} />
                </group>
            )))}
        </group>
      </group>

      {/* AR HUD */}
      {isARMode && (
        <group position={[0, 1.5, -4]}>
           <HolographicHUD />
        </group>
      )}

    </group>
  );
};
--- END OF FILE: src\components\canvas\board\QuantumBoard.tsx ---


--- START OF FILE: src\components\canvas\board\QubitNode.tsx ---
// src/components/canvas/board/QubitNode.tsx
import { useRef, useState, memo } from 'react';
import { useFrame, type ThreeEvent } from '@react-three/fiber';
import * as THREE from 'three';
import { type Qubit } from '../../../engine/core/QuantumLogic';
import { useGameStore } from '../../../store/gameStore';

// SUB-COMPONENTS
import { EmptyCell } from '../cells/EmptyCell';
import { StableCell } from '../cells/StableCell';
import { LockedCell } from '../cells/LockedCell';
import { FluxCell } from '../cells/FluxCell';

interface QubitNodeProps {
  data: Qubit;
  index: number; 
}

const QubitNodeComponent = ({ data, index }: QubitNodeProps) => {
  const groupRef = useRef<THREE.Group>(null);
  
  // OPTIMIZATION #8: Granular Selectors
  // Only subscribe to what matters for THIS interaction
  const draggingGate = useGameStore(s => s.draggingGate);
  const selectedGate = useGameStore(s => s.selectedGate);
  const executeMove = useGameStore(s => s.executeMove);
  
  // We need current player to enable/disable interaction
  const currentPlayer = useGameStore(s => s.currentPlayer);
  const isMultiplayer = useGameStore(s => s.isMultiplayer);
  const myRole = useGameStore(s => s.myRole);
  
  // These stop interaction globally
  const winner = useGameStore(s => s.winner);
  const isAIThinking = useGameStore(s => s.isAIThinking);

  // --- TURN LOGIC ---
  const isMyTurn = isMultiplayer 
    ? currentPlayer === myRole 
    : currentPlayer === 'blue';

  // --- ANIMATION STATE ---
  const [mountedAt] = useState(() => Date.now());
  
  useFrame((_state, delta) => {
    if (!groupRef.current) return;

    // 1. STAGGERED SPAWN LOGIC
    // Using time delta ensures smooth animation regardless of framerate
    const timeSinceMount = (Date.now() - mountedAt) / 1000;
    const delay = index * 0.02; 
    
    let targetScale = 0;
    if (timeSinceMount > delay) {
        targetScale = 1.0;
    }

    // 2. SMOOTH LERP (Optimization: Sleep when reached target)
    if (Math.abs(groupRef.current.scale.x - targetScale) > 0.01) {
        const speed = 8;
        // Optimization: Lerp scalar instead of creating new Vectors every frame
        const s = THREE.MathUtils.lerp(groupRef.current.scale.x, targetScale, delta * speed);
        groupRef.current.scale.setScalar(s);
    } else if (targetScale === 1 && groupRef.current.scale.x !== 1) {
        groupRef.current.scale.setScalar(1);
    }
  });

  // --- INTERACTION ---
  const handlePointerUp = (e: ThreeEvent<PointerEvent>) => {
    e.stopPropagation(); 
    
    if (!isMyTurn || winner || isAIThinking) return;

    // OPTIMIZATION #17: Haptic Feedback
    if (navigator.vibrate) navigator.vibrate(10);

    const gate = draggingGate || selectedGate;
    executeMove(data.id, gate);
  };

  return (
    <group 
      ref={groupRef} 
      position={[data.x * 1.1, 0, data.y * 1.1]}
      scale={[0, 0, 0]} 
    >
      {data.status === null && (
        <EmptyCell id={data.id} onClick={handlePointerUp} />
      )}
      
      {data.status === 'STABLE' && (
        <StableCell owner={data.owner} justSpawned={true} />
      )}

      {data.status === 'LOCKED' && data.owner && (
        <LockedCell owner={data.owner} />
      )}

      {data.status === 'FLUX' && (
        <FluxCell />
      )}
    </group>
  );
};

// OPTIMIZATION #8: Memoization
// Only re-render if the cell data changes or the turn changes (for interaction enabling)
export const QubitNode = memo(QubitNodeComponent, (prev, next) => {
  // Check Data Integrity
  if (prev.data.status !== next.data.status) return false;
  if (prev.data.owner !== next.data.owner) return false;
  if (prev.data.fluxOwner !== next.data.fluxOwner) return false;
  
  // We cannot easily compare store state inside memo without passing it as props.
  // Ideally, QubitNode should receive `isMyTurn` as a prop from the parent to make memo work perfectly.
  // However, even this basic check prevents re-renders when *other* cells change.
  return true; 
});
--- END OF FILE: src\components\canvas\board\QubitNode.tsx ---


--- START OF FILE: src\components\canvas\cells\EmptyCell.tsx ---
// src/components/canvas/cells/EmptyCell.tsx
import { useRef, useState } from 'react';
import { useFrame, type ThreeEvent } from '@react-three/fiber';
import * as THREE from 'three';
import { useGameStore } from '../../../store/gameStore';

interface EmptyCellProps {
  id: number;
  onClick: (e: ThreeEvent<PointerEvent>) => void;
}

// 1. SHARED GEOMETRY
const RING_GEO = new THREE.TorusGeometry(0.35, 0.015, 8, 32); 
const GHOST_GEO = new THREE.IcosahedronGeometry(0.25, 0);
const HITBOX_GEO = new THREE.PlaneGeometry(0.95, 0.95);

// COLORS
const COL_DEFAULT = new THREE.Color('#444444'); 
const COL_BLUE = new THREE.Color('#00f3ff');
const COL_GREEN = new THREE.Color('#00ff41');
const COL_PINK = new THREE.Color('#ff0055');

export const EmptyCell = ({ id, onClick }: EmptyCellProps) => {
  // --- SELECTORS ---
  const draggingGate = useGameStore(s => s.draggingGate);
  const selectedGate = useGameStore(s => s.selectedGate);
  const currentPlayer = useGameStore(s => s.currentPlayer);
  const isMultiplayer = useGameStore(s => s.isMultiplayer);
  const myRole = useGameStore(s => s.myRole);
  const setHoveredCell = useGameStore(s => s.setHoveredCell);

  const isMyTurn = isMultiplayer 
    ? currentPlayer === myRole 
    : currentPlayer === 'blue';

  const [hovered, setHovered] = useState(false);
  
  const ringRef = useRef<THREE.Mesh>(null);
  const ghostRef = useRef<THREE.Mesh>(null);
  const ringMatRef = useRef<THREE.MeshBasicMaterial>(null);
  const ghostMatRef = useRef<THREE.MeshBasicMaterial>(null);

  // Helper for lerping (Persistent memory)
  const lerpColor = useRef(new THREE.Color('#444444'));

  useFrame((state, delta) => {
    if (!ringRef.current || !ghostRef.current || !ringMatRef.current || !ghostMatRef.current) return;
    
    // Cap delta for consistent animation speed even during lag
    const dt = Math.min(delta, 0.1);
    const t = state.clock.getElapsedTime();

    // --- 1. DETERMINE STATE ---
    let targetColor = COL_DEFAULT;
    let targetOpacity = 0.3; 
    let targetScale = 1.0;
    
    // Only show active hover effects if it's the player's turn
    if (hovered && isMyTurn) {
        targetOpacity = 1.0; 
        targetScale = 1.15;
        
        const type = draggingGate || selectedGate;
        if (type === 'Z') targetColor = COL_BLUE;
        else if (type === 'X') targetColor = COL_GREEN;
        else if (type === 'H') targetColor = COL_PINK;
    }

    // --- 2. UPDATE VISUALS ---
    
    // Color Lerp
    lerpColor.current.lerp(targetColor, dt * 15);
    ringMatRef.current.color.copy(lerpColor.current);
    ghostMatRef.current.color.copy(lerpColor.current);

    // Ring Animation
    ringMatRef.current.opacity = THREE.MathUtils.lerp(ringMatRef.current.opacity, targetOpacity, dt * 10);
    
    const currentScale = ringRef.current.scale.x;
    const newScale = THREE.MathUtils.lerp(currentScale, targetScale, dt * 15);
    ringRef.current.scale.setScalar(newScale);

    // Ghost Animation (Preview of the piece you are about to place)
    if (hovered && isMyTurn) {
        ghostRef.current.visible = true;
        ghostRef.current.rotation.y += dt * 2;
        
        ghostMatRef.current.opacity = THREE.MathUtils.lerp(ghostMatRef.current.opacity, 0.6, dt * 10);
        
        // Scale up only if not already full size
        if (ghostRef.current.scale.x < 0.99) {
            ghostRef.current.scale.lerp(new THREE.Vector3(1,1,1), dt * 10);
        }
        
        // Bobbing effect
        ghostRef.current.position.y = 0.45 + Math.sin(t * 5) * 0.05;
    } else {
        // Fade Out logic
        if (ghostMatRef.current.opacity > 0.01) {
            ghostMatRef.current.opacity = THREE.MathUtils.lerp(ghostMatRef.current.opacity, 0, dt * 20);
            ghostRef.current.scale.lerp(new THREE.Vector3(0,0,0), dt * 20);
        } else {
            ghostRef.current.visible = false;
        }
    }
  });

  return (
    <group position={[0, -0.4, 0]}> 
      
      {/* 1. HITBOX */}
      <mesh 
        geometry={HITBOX_GEO} 
        rotation={[-Math.PI / 2, 0, 0]}
        onPointerUp={(e) => {
            e.stopPropagation();
            onClick(e);
        }}
        onPointerOver={(e) => {
            e.stopPropagation(); 
            if (isMyTurn) {
                setHovered(true);
                setHoveredCell(id);
            }
        }}
        onPointerOut={(e) => {
            e.stopPropagation();
            setHovered(false);
            setHoveredCell(null);
        }}
      >
        <meshBasicMaterial visible={false} />
      </mesh>

      {/* 2. THE RING MARKER */}
      <mesh 
        ref={ringRef} 
        geometry={RING_GEO} 
        rotation={[-Math.PI / 2, 0, 0]}
      >
        <meshBasicMaterial 
            ref={ringMatRef} 
            transparent 
            opacity={0.3} 
        />
      </mesh>

      {/* 3. GHOST PREVIEW */}
      <mesh ref={ghostRef} geometry={GHOST_GEO} visible={false}>
          <meshBasicMaterial 
            ref={ghostMatRef} 
            wireframe 
            transparent 
            opacity={0} 
            toneMapped={false} 
          />
      </mesh>

    </group>
  );
};
--- END OF FILE: src\components\canvas\cells\EmptyCell.tsx ---


--- START OF FILE: src\components\canvas\cells\FluxCell.tsx ---
// src/components/canvas/cells/FluxCell.tsx
import { useRef, useMemo } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';

// --- SHARED GEOMETRIES (Optimization #18) ---
const CORE_GEO = new THREE.IcosahedronGeometry(0.25, 0); 
const RING_GEO = new THREE.TorusGeometry(0.4, 0.02, 8, 32);
const FLUX_GEO = new THREE.IcosahedronGeometry(0.45, 0); 

// --- COLORS ---
const COL_BLUE = new THREE.Color('#00f3ff');
const COL_RED = new THREE.Color('#ff0055');
const COL_FLUX = new THREE.Color('#aa00ff'); 

export const FluxCell = () => {
  const coreRef = useRef<THREE.Mesh>(null);
  
  const ring1Ref = useRef<THREE.Mesh>(null);
  const ring2Ref = useRef<THREE.Mesh>(null);
  const ring3Ref = useRef<THREE.Mesh>(null);

  const shellRef = useRef<THREE.Mesh>(null);
  
  // Persistent color object to avoid GC
  const tempColor = useMemo(() => new THREE.Color(), []);

  useFrame((state, delta) => {
    if (!coreRef.current || !shellRef.current) return;
    
    const t = state.clock.getElapsedTime();

    // ==========================================
    // 1. INNER CORE (Rotating & Pulsing)
    // ==========================================
    
    coreRef.current.rotation.x += delta * 1.5;
    coreRef.current.rotation.y += delta * 2.0;

    // Color Shifting (Blue <-> Red)
    // Optimization: Calculate sin once
    const blendFactor = (Math.sin(t * 2) + 1) / 2; 
    tempColor.lerpColors(COL_BLUE, COL_RED, blendFactor);

    // Update Colors
    // Casting to access .color is faster than ref updating in React
    (coreRef.current.material as THREE.MeshBasicMaterial).color.copy(tempColor);
    if(ring1Ref.current) (ring1Ref.current.material as THREE.MeshBasicMaterial).color.copy(tempColor);
    if(ring2Ref.current) (ring2Ref.current.material as THREE.MeshBasicMaterial).color.copy(tempColor);
    if(ring3Ref.current) (ring3Ref.current.material as THREE.MeshBasicMaterial).color.copy(tempColor);

    // ==========================================
    // 2. OUTER SHELL (Static Glitch)
    // ==========================================
    
    // Optimization: Modulo check is fast
    if (t % 0.12 < 0.02) {
        // Random glitch effect
        const rotX = Math.floor(Math.random() * 4) * (Math.PI / 2);
        const rotY = Math.floor(Math.random() * 4) * (Math.PI / 2);
        
        shellRef.current.rotation.set(rotX, rotY, 0);

        const scale = 1 + (Math.random() * 0.3);
        shellRef.current.scale.set(scale, scale, scale);
    }
  });

  return (
    <group>
        {/* --- INNER PARTS --- */}
        
        {/* Core: Rotating */}
        <mesh ref={coreRef} geometry={CORE_GEO}>
            <meshBasicMaterial toneMapped={false} />
        </mesh>

        {/* Rings: STATIC (Fixed rotation to look like a gyroscope) */}
        <mesh ref={ring1Ref} geometry={RING_GEO} scale={0.6} rotation={[Math.PI/2, 0, 0]}>
            <meshBasicMaterial toneMapped={false} transparent opacity={0.8} />
        </mesh>
        
        <mesh ref={ring2Ref} geometry={RING_GEO} scale={0.8} rotation={[0, Math.PI/2, 0]}>
            <meshBasicMaterial toneMapped={false} transparent opacity={0.6} />
        </mesh>
        
        <mesh ref={ring3Ref} geometry={RING_GEO} scale={1.0} rotation={[0, 0, Math.PI/4]}>
            <meshBasicMaterial toneMapped={false} transparent opacity={0.4} />
        </mesh>

        {/* --- OUTER SHELL --- */}
        <mesh ref={shellRef} geometry={FLUX_GEO}>
            <meshBasicMaterial 
                color={COL_FLUX}
                wireframe 
                toneMapped={false} 
                transparent 
                opacity={0.4} 
            />
        </mesh>
    </group>
  );
};
--- END OF FILE: src\components\canvas\cells\FluxCell.tsx ---


--- START OF FILE: src\components\canvas\cells\LockedCell.tsx ---
// src/components/canvas/cells/LockedCell.tsx
import { useRef } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';

interface LockedCellProps {
  owner: 'blue' | 'red';
}

const CORE_GEO = new THREE.IcosahedronGeometry(0.25, 0); 
const RING_GEO = new THREE.TorusGeometry(0.35, 0.02, 8, 32); 
const SHIELD_GEO = new THREE.DodecahedronGeometry(0.6, 0);
// Replacement for Points: Simple small box/sphere
const NODE_GEO = new THREE.BoxGeometry(0.08, 0.08, 0.08);

export const LockedCell = ({ owner }: LockedCellProps) => {
  const groupRef = useRef<THREE.Group>(null);
  
  const shieldRef = useRef<THREE.Group>(null);
  const ringXRef = useRef<THREE.Mesh>(null);
  const ringYRef = useRef<THREE.Mesh>(null);
  const ringZRef = useRef<THREE.Mesh>(null);

  const color = owner === 'blue' ? '#00f3ff' : '#ff0055';

  useFrame((state, delta) => {
    if (!shieldRef.current || !ringXRef.current || !ringYRef.current || !ringZRef.current) return;

    shieldRef.current.rotation.y -= delta * 0.2;
    shieldRef.current.rotation.z += delta * 0.1;

    ringXRef.current.rotation.x += delta * 0.8;
    ringYRef.current.rotation.y += delta * 0.6;
    ringZRef.current.rotation.z += delta * 0.4;

    if (groupRef.current) {
        groupRef.current.position.y = Math.sin(state.clock.elapsedTime) * 0.02;
    }
  });

  return (
    <group ref={groupRef}>
      
      {/* CORE */}
      <mesh geometry={CORE_GEO} scale={0.8}>
        <meshBasicMaterial color={color} toneMapped={false} />
      </mesh>

      {/* GYROSCOPE */}
      <mesh ref={ringXRef} geometry={RING_GEO} scale={0.7}>
        <meshBasicMaterial color={color} toneMapped={false} />
      </mesh>
      <mesh ref={ringYRef} geometry={RING_GEO} scale={0.9}>
        <meshBasicMaterial color={color} toneMapped={false} />
      </mesh>
      <mesh ref={ringZRef} geometry={RING_GEO} scale={1.1}>
        <meshBasicMaterial color={color} toneMapped={false} />
      </mesh>

      {/* SHIELD */}
      <group ref={shieldRef}>
        {/* Transparent Shell */}
        <mesh geometry={SHIELD_GEO} scale={0.95}>
            <meshBasicMaterial 
                color={color} 
                transparent 
                opacity={0.3} 
                depthWrite={false} 
                side={THREE.DoubleSide}
                toneMapped={false}
            />
        </mesh>
        
        {/* Wireframe */}
        <mesh geometry={SHIELD_GEO} scale={1.0}>
            <meshBasicMaterial color="white" wireframe transparent opacity={0.5} toneMapped={false} />
        </mesh>
        
        {/* Corner Nodes (Replaced Points with simple meshes for stability) */}
        {/* We place 8 corners roughly */}
        {[
          [1,1,1], [1,1,-1], [1,-1,1], [1,-1,-1],
          [-1,1,1], [-1,1,-1], [-1,-1,1], [-1,-1,-1]
        ].map((pos, i) => (
             <mesh key={i} geometry={NODE_GEO} position={pos.map(p => p * 0.5) as [number,number,number]}>
                 <meshBasicMaterial color="white" toneMapped={false} />
             </mesh>
        ))}
      </group>
    </group>
  );
};
--- END OF FILE: src\components\canvas\cells\LockedCell.tsx ---


--- START OF FILE: src\components\canvas\cells\StableCell.tsx ---
// src/components/canvas/cells/StableCell.tsx
import { useRef, useMemo } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';

interface StableCellProps {
  owner: 'blue' | 'red' | null;
  justSpawned?: boolean;
}

// SHARED GEOMETRY (Optimization)
const CORE_GEO = new THREE.IcosahedronGeometry(0.25, 0); 
const RING_GEO = new THREE.TorusGeometry(0.4, 0.02, 8, 32); 

export const StableCell = ({ owner }: StableCellProps) => {
  const groupRef = useRef<THREE.Group>(null);
  const coreRef = useRef<THREE.Group>(null);
  
  const ring1Ref = useRef<THREE.Mesh>(null);
  const ring2Ref = useRef<THREE.Mesh>(null);
  const ring3Ref = useRef<THREE.Mesh>(null);

  const color = owner === 'blue' ? '#00f3ff' : '#ff0055';
  
  // RANDOMIZED SPEEDS (Computed once per cell)
  const speeds = useMemo(() => [
    (Math.random() * 0.5 + 1) * (Math.random() > 0.5 ? 1 : -1), 
    (Math.random() * 0.5 + 1) * (Math.random() > 0.5 ? 1 : -1), 
    (Math.random() * 0.5 + 1) * (Math.random() > 0.5 ? 1 : -1), 
    (Math.random() * 0.5 + 1) * (Math.random() > 0.5 ? 1 : -1), 
    (Math.random() * 0.2 + 0.5) * (Math.random() > 0.5 ? 1 : -1),
  ], []);

  useFrame((state, delta) => {
    if (!coreRef.current || !ring1Ref.current || !ring2Ref.current || !ring3Ref.current) return;
    
    // Core Rotation
    coreRef.current.rotation.x += delta * 1.5;
    coreRef.current.rotation.y += delta * 2.0;

    // Ring Rotation
    ring1Ref.current.rotation.x += delta * speeds[0];
    ring1Ref.current.rotation.y += delta * speeds[1];

    ring2Ref.current.rotation.x += delta * speeds[2];
    ring2Ref.current.rotation.y += delta * speeds[3];

    ring3Ref.current.rotation.x += delta * speeds[4];
    
    // Hover Effect
    if (groupRef.current) {
      groupRef.current.position.y = Math.sin(state.clock.elapsedTime * 2) * 0.05;
    }
  });

  return (
    <group ref={groupRef}>
      <group ref={coreRef}>
        <mesh geometry={CORE_GEO} scale={0.8}>
            <meshBasicMaterial color={color} toneMapped={false} />
        </mesh>
        <mesh geometry={CORE_GEO} scale={1.1}>
            <meshBasicMaterial color="white" wireframe transparent opacity={0.5} />
        </mesh>
      </group>

      <mesh ref={ring1Ref} geometry={RING_GEO} scale={0.7}>
        <meshBasicMaterial color={color} toneMapped={false} opacity={1.0} transparent />
      </mesh>

      <mesh ref={ring2Ref} geometry={RING_GEO} scale={0.9}>
        <meshBasicMaterial color={color} toneMapped={false} opacity={0.8} transparent />
      </mesh>

      <mesh ref={ring3Ref} geometry={RING_GEO} scale={1.1}>
        <meshBasicMaterial color={color} toneMapped={false} opacity={0.6} transparent />
      </mesh>
    </group>
  );
};
--- END OF FILE: src\components\canvas\cells\StableCell.tsx ---


--- START OF FILE: src\components\canvas\effects\VFXManager.tsx ---
// src/components/canvas/effects/VFXManager.tsx
import { useThree } from '@react-three/fiber';
import { Sparkles } from '@react-three/drei';
import { useEffect } from 'react';
import * as THREE from 'three';
import { useGameStore } from '../../../store/gameStore';

export const VFXManager = () => {
  const { scene } = useThree();
  
  // STORE
  const currentPlayer = useGameStore(state => state.currentPlayer);
  const instability = useGameStore(state => state.instability);
  const winner = useGameStore(state => state.winner);
  const isARMode = useGameStore(state => state.isARMode);
  
  // 1. MANAGE ATMOSPHERE
  useEffect(() => {
    if (isARMode) {
      scene.fog = null;
      scene.background = null;
    } else {
      // Dark fog to blend the board edges into the void
      scene.fog = new THREE.FogExp2('#000000', 0.02);
    }
  }, [isARMode, scene]);

  return (
    <group>
      {/* 
          NOTE: ALL LIGHTS REMOVED. 
          Lighting is now handled exclusively by the QuantumBoard's internal reactor.
      */}

      {/* 2. AMBIENT PARTICLES */}
      <Sparkles 
        count={isARMode ? 30 : 60} 
        scale={12} 
        size={isARMode ? 4 : 2} 
        speed={0.2} 
        opacity={0.4} 
        color={currentPlayer === 'blue' ? "#00f3ff" : "#ff0055"} 
      />

      {/* 3. INSTABILITY EMBERS (High Stress) */}
      {instability > 50 && (
        <Sparkles 
          count={Math.floor(instability)} 
          scale={10} 
          size={4} 
          speed={1.5} 
          opacity={0.6}
          color={instability > 80 ? "#ff0000" : "#ffaa00"}
          noise={0.5}
        />
      )}

      {/* 4. VICTORY/DEFEAT CONFETTI */}
      {winner && (
        <Sparkles 
          count={300} 
          scale={15} 
          size={8} 
          speed={0.5} 
          opacity={1}
          color={winner === 'blue' ? "#00f3ff" : "#ff0055"}
          noise={1} 
        />
      )}
    </group>
  );
};
--- END OF FILE: src\components\canvas\effects\VFXManager.tsx ---


--- START OF FILE: src\components\canvas\ui\HoloGateCard.tsx ---
// src/components/canvas/ui/HoloGateCard.tsx
import { useState, useMemo, useRef } from 'react';
import { Text, RoundedBox } from '@react-three/drei';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';

// --- 3D PREVIEWS (Identical to DOM version, but native Three.js) ---
const InjectorPreview = () => {
  const ref = useRef<THREE.Group>(null);
  const geo = useMemo(() => new THREE.IcosahedronGeometry(0.5, 0), []);
  const ring = useMemo(() => new THREE.TorusGeometry(0.8, 0.04, 4, 16), []);
  useFrame((state) => { if(ref.current) ref.current.rotation.y = state.clock.elapsedTime; });
  return (
    <group ref={ref}>
      <mesh geometry={geo}><meshBasicMaterial color="#00ff41" wireframe transparent opacity={0.3} /></mesh>
      <mesh geometry={geo} scale={0.7}><meshBasicMaterial color="#00ff41" toneMapped={false} /></mesh>
      <mesh geometry={ring} rotation={[1.5,0,0]}><meshBasicMaterial color="white" transparent opacity={0.5} /></mesh>
    </group>
  );
};

const FirewallPreview = () => {
  const ref = useRef<THREE.Group>(null);
  const shield = useMemo(() => new THREE.DodecahedronGeometry(0.7, 0), []);
  const core = useMemo(() => new THREE.IcosahedronGeometry(0.3, 0), []);
  useFrame((state) => { if(ref.current) ref.current.rotation.y = -state.clock.elapsedTime * 0.5; });
  return (
    <group ref={ref}>
      <mesh geometry={shield}><meshBasicMaterial color="#00f3ff" wireframe transparent opacity={0.2} /></mesh>
      <mesh geometry={core}><meshBasicMaterial color="#00f3ff" toneMapped={false} /></mesh>
    </group>
  );
};

const VirusPreview = () => {
  const ref = useRef<THREE.Group>(null);
  const geo = useMemo(() => new THREE.IcosahedronGeometry(0.6, 0), []);
  useFrame((state) => { 
      if(ref.current && state.clock.getElapsedTime() % 0.2 < 0.05) {
          ref.current.rotation.set(Math.random()*3, Math.random()*3, 0);
      }
  });
  return (
    <group ref={ref}>
      <mesh geometry={geo}><meshBasicMaterial color="#ff0055" wireframe transparent opacity={0.4} /></mesh>
      <mesh geometry={geo} scale={0.5}><meshBasicMaterial color="#aa00ff" toneMapped={false} /></mesh>
    </group>
  );
};

// --- MAIN COMPONENT ---
interface HoloCardProps {
  type: string;
  name: string; // Updated from 'label' to match HUD
  x: number;
  selected: boolean;
  disabled: boolean;
  onClick: () => void;
}

export const HoloGateCard = ({ type, name, x, selected, disabled, onClick }: HoloCardProps) => {
  const [hovered, setHover] = useState(false);
  
  // Theme Config
  const config = useMemo(() => {
    if (type === 'Z') return { color: "#00f3ff" };
    if (type === 'X') return { color: "#00ff41" };
    return { color: "#ff0055" };
  }, [type]);

  const isActive = selected;
  const scale = isActive ? 1.1 : hovered ? 1.05 : 1.0;
  const borderColor = isActive ? config.color : hovered ? "#ffffff" : "#444444";

  return (
    <group 
      position={[x, 0, 0]} 
      scale={[scale, scale, scale]}
      onClick={(e) => { 
        if(disabled) return;
        e.stopPropagation(); 
        onClick(); 
      }} 
      onPointerOver={() => !disabled && setHover(true)} 
      onPointerOut={() => setHover(false)}
    >
      
      {/* 1. GLASS SLAB (Physical Body) */}
      <RoundedBox args={[1.6, 2.2, 0.1]} radius={0.1}>
        <meshPhysicalMaterial 
            color="#000000" 
            roughness={0.1} 
            metalness={0.9} 
            transmission={0.6} 
            transparent 
            opacity={0.5}
        />
      </RoundedBox>

      {/* 2. BORDER GLOW */}
      <mesh position={[0, 0, -0.01]}>
        <RoundedBox args={[1.65, 2.25, 0.08]} radius={0.1}>
           <meshBasicMaterial color={borderColor} transparent opacity={isActive ? 0.8 : 0.3} />
        </RoundedBox>
      </mesh>

      {/* 3. 3D CONTENT (Floating inside) */}
      <group position={[0, 0, 0]}>
         {type === 'Z' && <FirewallPreview />}
         {type === 'X' && <InjectorPreview />}
         {type === 'H' && <VirusPreview />}
      </group>

      {/* 4. TEXT OVERLAYS */}
      <group position={[0, 0, 0.06]}>
        {/* Top Type */}
        <Text 
            position={[-0.6, 0.9, 0]} 
            fontSize={0.2} 
            color={config.color} 
            anchorX="left" 
            fontWeight="bold"
        >
            {type}
        </Text>

        {/* Bottom Badge Name */}
        <group position={[0, -0.8, 0]}>
            <RoundedBox args={[1.2, 0.25, 0.02]} radius={0.1}>
                <meshBasicMaterial color="#111" transparent opacity={0.8} />
            </RoundedBox>
            <Text 
                position={[0, 0, 0.02]} 
                fontSize={0.12} 
                color="white" 
                fontWeight="bold"
                letterSpacing={0.1}
            >
                {name}
            </Text>
        </group>
      </group>

      {/* 5. ACTIVE LIGHT (Top Indicator) */}
      {isActive && (
        <mesh position={[0, 1.2, 0]}>
            <boxGeometry args={[0.8, 0.05, 0.05]} />
            <meshBasicMaterial color={config.color} toneMapped={false} />
        </mesh>
      )}

    </group>
  );
};
--- END OF FILE: src\components\canvas\ui\HoloGateCard.tsx ---


--- START OF FILE: src\components\canvas\ui\HolographicHUD.tsx ---
// src/components/canvas/ui/HolographicHUD.tsx
import { useMemo, useState } from 'react';
import { Text, RoundedBox } from '@react-three/drei';
import { useXR } from '@react-three/xr';
import { useGameStore } from '../../../store/gameStore';
import { HoloGateCard } from './HoloGateCard';

// Reliable font URL
const FONT_URL = 'https://fonts.gstatic.com/s/inter/v12/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuFuYAZ9hjp-Ek-_EeA.woff';

const GameOverModal = ({ winner, scores, onExit }: any) => {
  const session = useXR((state) => state.session);
  const [hovered, setHover] = useState(false);

  const config = useMemo(() => {
    if (winner === 'blue') return { title: "VICTORY", text: "SYSTEM OVERRIDDEN.", color: "#00f3ff" };
    if (winner === 'red') return { title: "DEFEAT", text: "INTRUSION DETECTED.", color: "#ff0055" };
    return { title: "CRITICAL FAILURE", text: "CORE MELTDOWN.", color: "#facc15" };
  }, [winner]);

  const handleReboot = () => {
    if (session) session.end().catch((e) => console.warn(e));
    onExit();
  };

  return (
    <group position={[0, 2.5, 0]} rotation={[-Math.PI / 6, 0, 0]}>
      {/* Background Panel */}
      <RoundedBox args={[4, 2.5, 0.05]} radius={0.1} renderOrder={1}>
        <meshBasicMaterial color="black" transparent opacity={0.8} depthWrite={false} toneMapped={false} />
      </RoundedBox>
      {/* Border Glow */}
      <mesh position={[0, 0, -0.01]} renderOrder={1}>
         <planeGeometry args={[4.1, 2.6]} />
         <meshBasicMaterial color={config.color} transparent opacity={0.5} depthWrite={false} toneMapped={false} />
      </mesh>

      <group position={[0, 0, 0.1]}>
        <Text font={FONT_URL} renderOrder={2} position={[0, 0.6, 0]} fontSize={0.5} fontWeight="black" anchorX="center" anchorY="middle">
          {config.title}
          <meshBasicMaterial attach="material" color={config.color} toneMapped={false} depthTest={false} />
        </Text>
        
        <Text font={FONT_URL} renderOrder={2} position={[0, 0.2, 0]} fontSize={0.15} letterSpacing={0.1} anchorX="center" anchorY="middle">
          {config.text}
          <meshBasicMaterial attach="material" color="white" toneMapped={false} depthTest={false} />
        </Text>
        
        <group position={[0, -0.3, 0]}>
           <Text font={FONT_URL} renderOrder={2} position={[-1, 0.2, 0]} fontSize={0.15}>
             HACKER
             <meshBasicMaterial attach="material" color="#00f3ff" toneMapped={false} depthTest={false} />
           </Text>
           <Text font={FONT_URL} renderOrder={2} position={[-1, -0.2, 0]} fontSize={0.4} fontWeight="bold">
             {scores.blue}
             <meshBasicMaterial attach="material" color="white" toneMapped={false} depthTest={false} />
           </Text>
           
           <Text font={FONT_URL} renderOrder={2} position={[1, 0.2, 0]} fontSize={0.15}>
             SECURITY
             <meshBasicMaterial attach="material" color="#ff0055" toneMapped={false} depthTest={false} />
           </Text>
           <Text font={FONT_URL} renderOrder={2} position={[1, -0.2, 0]} fontSize={0.4} fontWeight="bold">
             {scores.red}
             <meshBasicMaterial attach="material" color="white" toneMapped={false} depthTest={false} />
           </Text>
        </group>

        <group 
            position={[0, -0.9, 0.1]} 
            onClick={(e) => { e.stopPropagation(); handleReboot(); }}
            onPointerOver={() => setHover(true)}
            onPointerOut={() => setHover(false)}
            scale={hovered ? 1.05 : 1.0}
        >
            <RoundedBox args={[2.5, 0.5, 0.1]} radius={0.1} renderOrder={2}>
                <meshBasicMaterial color={hovered ? "white" : "#222"} toneMapped={false} depthTest={false} />
            </RoundedBox>
            <Text font={FONT_URL} renderOrder={3} position={[0, 0, 0.06]} fontSize={0.2} fontWeight="bold">
                REBOOT SYSTEM
                <meshBasicMaterial attach="material" color={hovered ? "black" : "white"} toneMapped={false} depthTest={false} />
            </Text>
        </group>
      </group>
    </group>
  );
};

export const HolographicHUD = () => {
  const { 
    scores, instability, selectedGate, setSelectedGate, 
    currentPlayer, winner, setARPlaced, exitGame, 
    isMultiplayer, myRole 
  } = useGameStore();

  const canInteract = isMultiplayer ? currentPlayer === myRole : currentPlayer === 'blue';
  const [hoveredRelocate, setHoveredRelocate] = useState(false);

  if (winner) {
    return <GameOverModal winner={winner} scores={scores} onExit={exitGame} />;
  }

  return (
    <group>
      
      {/* 1. TOP HUD CONTAINER */}
      <group position={[0, 3, -2]} scale={[1.9, 1.9, 1.9]} rotation={[-Math.PI / 7, 0, 0]}>
        
        {/* === BLUE SCORE PANEL === */}
        <group position={[-2.5, 0, 0]}>
            {/* Background */}
            <RoundedBox args={[1.2, 1.0, 0.05]} radius={0.05} renderOrder={1}>
                <meshBasicMaterial color="black" transparent opacity={0.7} depthWrite={false} toneMapped={false} />
            </RoundedBox>
            {/* Border */}
            <mesh position={[0, 0, -0.01]} renderOrder={1}>
                <planeGeometry args={[1.25, 1.05]} />
                <meshBasicMaterial color="#00f3ff" transparent opacity={0.5} depthWrite={false} toneMapped={false} />
            </mesh>
            {/* Text Content */}
            <group position={[0, 0, 0.06]}>
                <Text font={FONT_URL} renderOrder={2} position={[0, 0.3, 0]} fontSize={0.12} fontWeight="bold">
                    Hacker
                    <meshBasicMaterial attach="material" color="#00f3ff" toneMapped={false} depthTest={false} />
                </Text>
                <Text font={FONT_URL} renderOrder={2} position={[0, -0.1, 0]} fontSize={0.5} fontWeight="bold">
                    {scores.blue}
                    <meshBasicMaterial attach="material" color="white" toneMapped={false} depthTest={false} />
                </Text>
            </group>
        </group>

        {/* === INSTABILITY BAR === */}
        <group position={[0, 0.1, 0]}>
            <Text font={FONT_URL} renderOrder={2} position={[-1.5, 0.3, 0]} fontSize={0.1} anchorX="left">
                INSTABILITY
                <meshBasicMaterial attach="material" color="gray" toneMapped={false} depthTest={false} />
            </Text>
            <Text font={FONT_URL} renderOrder={2} position={[1.5, 0.3, 0]} fontSize={0.1} anchorX="right">
                {Math.floor(instability)}%
                <meshBasicMaterial attach="material" color={instability > 80 ? "#ff0055" : "white"} toneMapped={false} depthTest={false} />
            </Text>
            
            <RoundedBox position={[0, 0, 0]} args={[3.0, 0.2, 0.05]} radius={0.05} renderOrder={1}>
                <meshBasicMaterial color="#111" toneMapped={false} />
            </RoundedBox>
            
            <group position={[-1.45, 0, 0.04]}>
                {[...Array(20)].map((_, i) => {
                    const threshold = (i + 1) * 5;
                    const active = instability >= threshold;
                    const color = threshold > 80 ? '#ff0055' : threshold > 50 ? '#aa00ff' : '#00f3ff';
                    if (!active) return null;
                    return (
                        <mesh key={i} position={[(i * 0.15) + 0.07, 0, 0]} renderOrder={2}>
                            <boxGeometry args={[0.12, 0.12, 0.02]} />
                            <meshBasicMaterial color={color} toneMapped={false} depthTest={false} />
                        </mesh>
                    );
                })}
            </group>
        </group>

        {/* === RED SCORE PANEL === */}
        <group position={[2.5, 0, 0]}>
            {/* Background */}
            <RoundedBox args={[1.2, 1.0, 0.05]} radius={0.05} renderOrder={1}>
                <meshBasicMaterial color="black" transparent opacity={0.7} depthWrite={false} toneMapped={false} />
            </RoundedBox>
            {/* Border */}
            <mesh position={[0, 0, -0.01]} renderOrder={1}>
                <planeGeometry args={[1.25, 1.05]} />
                <meshBasicMaterial color="#ff0055" transparent opacity={0.5} depthWrite={false} toneMapped={false} />
            </mesh>
            {/* Text Content */}
            <group position={[0, 0, 0.06]}>
                <Text font={FONT_URL} renderOrder={2} position={[0, 0.3, 0]} fontSize={0.12} fontWeight="bold">
                    AI
                    <meshBasicMaterial attach="material" color="#ff0055" toneMapped={false} depthTest={false} />
                </Text>
                <Text font={FONT_URL} renderOrder={2} position={[0, -0.1, 0]} fontSize={0.5} fontWeight="bold">
                    {scores.red}
                    <meshBasicMaterial attach="material" color="white" toneMapped={false} depthTest={false} />
                </Text>
            </group>
        </group>

        {/* === RELOCATE BUTTON === */}
        <group 
          position={[0, -0.7, 0]} 
          onClick={(e) => { e.stopPropagation(); setARPlaced(false); }}
          onPointerOver={() => setHoveredRelocate(true)}
          onPointerOut={() => setHoveredRelocate(false)}
          scale={hoveredRelocate ? 1.05 : 1.0}
        >
          <RoundedBox args={[1.8, 0.35, 0.05]} radius={0.05} renderOrder={1}>
             <meshBasicMaterial color="black" transparent opacity={0.7} depthWrite={false} toneMapped={false} />
          </RoundedBox>
          <mesh position={[0, 0, -0.01]} renderOrder={1}>
             <planeGeometry args={[1.85, 0.4]} />
             <meshBasicMaterial color={hoveredRelocate ? "white" : "#333"} transparent opacity={0.5} depthWrite={false} toneMapped={false} />
          </mesh>
          
          <group position={[0, 0, 0.06]}>
             <Text font={FONT_URL} renderOrder={2} fontSize={0.12} fontWeight="bold">
                โฅ RELOCATE BOARD
                <meshBasicMaterial attach="material" color={hoveredRelocate ? "white" : "gray"} toneMapped={false} depthTest={false} />
             </Text>
          </group>
        </group>
      </group>

      {/* 2. BOTTOM HUD (Cards) */}
      <group position={[0, -1.5, 9.8]} rotation={[-Math.PI / 3, 0, 0]}>
        <HoloGateCard 
            type="Z" name="FIREWALL" x={-2} 
            selected={selectedGate === 'Z'} 
            disabled={!canInteract} 
            onClick={() => canInteract && setSelectedGate('Z')} 
        />
        <HoloGateCard 
            type="X" name="INJECTOR" x={0} 
            selected={selectedGate === 'X'} 
            disabled={!canInteract} 
            onClick={() => canInteract && setSelectedGate('X')} 
        />
        <HoloGateCard 
            type="H" name="VIRUS" x={2} 
            selected={selectedGate === 'H'} 
            disabled={!canInteract} 
            onClick={() => canInteract && setSelectedGate('H')} 
        />
      </group>

    </group>
  );
};
--- END OF FILE: src\components\canvas\ui\HolographicHUD.tsx ---


--- START OF FILE: src\components\dom\hud\GameHUD.tsx ---
// src/components/dom/hud/GameHUD.tsx
import { useEffect, useState, useMemo } from 'react';
import { useGameStore } from '../../../store/gameStore';
import { motion } from 'framer-motion';
import { useNavigate } from 'react-router-dom';
import { GateCard } from './GateCard';

export const GameHUD = () => {
  const navigate = useNavigate();

  const { 
    scores, instability, winner, 
    draggingGate, hoveredCell, 
    setSelectedGate, setDraggingGate, executeMove, exitGame, isMultiplayer,
    isARMode 
  } = useGameStore();

  const [mousePos, setMousePos] = useState({ x: 0, y: 0 });

  // --- DRAG LOGIC ---
  useEffect(() => {
    const handleMove = (e: PointerEvent) => {
      if (draggingGate) setMousePos({ x: e.clientX, y: e.clientY });
    };
    
    const handleUp = () => {
      if (draggingGate) {
        if (hoveredCell !== null) {
          executeMove(hoveredCell, draggingGate);
        }
        setDraggingGate(null);
      }
    };
    
    window.addEventListener('pointermove', handleMove);
    window.addEventListener('pointerup', handleUp);
    return () => {
      window.removeEventListener('pointermove', handleMove);
      window.removeEventListener('pointerup', handleUp);
    };
  }, [draggingGate, hoveredCell, executeMove, setDraggingGate]);

  const handleDragStart = (e: React.PointerEvent, type: any) => {
    setSelectedGate(type);
    setDraggingGate(type);
    setMousePos({ x: e.clientX, y: e.clientY });
  };

  const handleReboot = () => {
    exitGame();
    if (isMultiplayer) navigate('/lobby');
    else navigate('/setup');
  };

  if (isARMode) return null;

  // --- COMPONENT: GHOST CARD ---
  const GhostCard = () => {
    if (!draggingGate) return null;
    
    const colors = { 
        Z: 'border-cyan-500 text-cyan-400', 
        X: 'border-green-500 text-green-400', 
        H: 'border-pink-500 text-pink-500' 
    }[draggingGate];
    
    return (
      <div 
        className={`
            fixed z-[100] pointer-events-none 
            w-16 h-20 rounded-lg border-2 ${colors?.split(' ')[0]} 
            bg-black/80 backdrop-blur-md shadow-2xl
            flex items-center justify-center
        `}
        style={{ 
            left: mousePos.x, 
            top: mousePos.y, 
            transform: 'translate(-50%, -50%)' 
        }}
      >
        <span className={`text-2xl font-black ${colors?.split(' ')[1]}`}>
            {draggingGate}
        </span>
      </div>
    );
  };

  // --- COMPONENT: CINEMATIC END SCREEN ---
  const GameOverModal = () => {
    if (!winner) return null;

    // exact configuration requested
    const config = useMemo(() => {
        if (winner === 'blue') return {
            title: "VICTORY",
            text: "SYSTEM OVERRIDDEN. ACCESS GRANTED.",
            color: "text-cyan-400",
            border: "border-cyan-500",
            glow: "shadow-[inset_0_0_100px_rgba(34,211,238,0.2)]" // Blue Vignette
        };
        if (winner === 'red') return {
            title: "DEFEAT",
            text: "INTRUSION DETECTED. NEURAL LINK SEVERED.",
            color: "text-pink-500",
            border: "border-pink-500",
            glow: "shadow-[inset_0_0_100px_rgba(236,72,153,0.2)]" // Red Vignette
        };
        return { // Draw
            title: "CRITICAL FAILURE",
            text: "โ CORE MELTDOWN IMMINENT. EVACUATE IMMEDIATELY.",
            color: "text-yellow-400",
            border: "border-yellow-400",
            glow: "shadow-[inset_0_0_100px_rgba(250,204,21,0.2)] animate-pulse" // Yellow/Warning Vignette
        };
    }, [winner]);
    
    return (
      <motion.div 
        initial={{ opacity: 0 }} 
        animate={{ opacity: 1 }} 
        // FIX: Added pointer-events-auto so the button works
        className={`fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-md ${config.glow} pointer-events-auto`}
      >
        <motion.div 
          initial={{ scale: 0.9, y: 20 }} 
          animate={{ scale: 1, y: 0 }}
          className={`w-full max-w-lg bg-black/60 border-2 ${config.border} p-10 rounded-2xl shadow-2xl backdrop-blur-xl text-center`}
        >
          {/* Header */}
          <h1 className={`text-5xl md:text-6xl font-black mb-4 tracking-tighter drop-shadow-lg ${config.color}`}>
            {config.title}
          </h1>
          
          {/* Subtitle Message */}
          <div className={`text-xs md:text-sm font-bold font-mono mb-10 tracking-[0.15em] border-t border-b border-white/10 py-4 ${config.color}`}>
            {config.text}
          </div>
          
          {/* Scores Display */}
          <div className="flex justify-center gap-12 mb-10">
             <div className="text-center">
                <div className="text-[10px] font-bold text-cyan-400 mb-2 tracking-widest">HACKER</div>
                <div className="text-5xl font-black text-white">{scores.blue}</div>
             </div>
             <div className="w-px bg-white/10"></div>
             <div className="text-center">
                <div className="text-[10px] font-bold text-pink-500 mb-2 tracking-widest">SECURITY</div>
                <div className="text-5xl font-black text-white">{scores.red}</div>
             </div>
          </div>

          {/* Action Button */}
          <button 
            onClick={handleReboot} 
            className={`
                w-full py-5 bg-white/5 hover:bg-white/10 border border-white/20 
                text-white font-black tracking-[0.3em] transition-all rounded-lg 
                shadow-lg hover:shadow-xl hover:scale-[1.02] active:scale-[0.98]
            `}
          >
            {isMultiplayer ? "RETURN TO LOBBY" : "REBOOT SYSTEM"}
          </button>
        </motion.div>
      </motion.div>
    );
  };

  return (
    <>
      <GhostCard />
      <GameOverModal />

      {/* --- HUD LAYOUT --- */}
      <div className="absolute inset-0 pointer-events-none flex flex-col justify-between p-4 z-40 overflow-hidden">
        
        {/* TOP BAR */}
        <div className="w-full max-w-3xl mx-auto mt-4 flex items-center gap-4">
            {/* BLUE */}
            <div className="bg-black/40 border border-cyan-500/30 backdrop-blur-md p-3 rounded-lg min-w-[80px] text-center shadow-lg">
                <div className="text-[9px] font-black text-cyan-400 tracking-widest mb-1">BLUE</div>
                <div className="text-2xl font-black text-white leading-none">{scores.blue}</div>
            </div>

            {/* ENTROPY */}
            <div className="flex-1 bg-black/40 border border-white/10 backdrop-blur-md p-3 rounded-lg flex flex-col justify-center shadow-lg">
                <div className="flex justify-between text-[9px] font-bold text-gray-400 mb-2 tracking-widest px-1">
                    <span>SYSTEM INSTABILITY</span>
                    <span className={instability > 80 ? "text-red-500 animate-pulse" : "text-white"}>{Math.floor(instability)}%</span>
                </div>
                <div className="w-full h-2 bg-gray-800/50 rounded-full overflow-hidden flex gap-0.5">
                    {[...Array(20)].map((_, i) => {
                        const threshold = (i + 1) * 5; 
                        const active = instability >= threshold;
                        const color = threshold > 80 ? 'bg-red-500' : threshold > 50 ? 'bg-purple-500' : 'bg-cyan-500';
                        return (
                            <div 
                                key={i} 
                                className={`flex-1 transition-all duration-300 ${active ? `${color} shadow-[0_0_5px_currentColor]` : 'bg-white/5'}`} 
                            />
                        );
                    })}
                </div>
            </div>

            {/* RED */}
            <div className="bg-black/40 border border-pink-500/30 backdrop-blur-md p-3 rounded-lg min-w-[80px] text-center shadow-lg">
                <div className="text-[9px] font-black text-pink-500 tracking-widest mb-1">RED</div>
                <div className="text-2xl font-black text-white leading-none">{scores.red}</div>
            </div>
        </div>
        
        {/* BOTTOM BAR */}
        <div className="w-full flex justify-center items-end pb-6 pointer-events-auto gap-4">
          <GateCard type="Z" onDragStart={(e) => handleDragStart(e, 'Z')} />
          <GateCard type="X" onDragStart={(e) => handleDragStart(e, 'X')} />
          <GateCard type="H" onDragStart={(e) => handleDragStart(e, 'H')} />
        </div>

      </div>
    </>
  );
};
--- END OF FILE: src\components\dom\hud\GameHUD.tsx ---


--- START OF FILE: src\components\dom\hud\GateCard.tsx ---
// src/components/dom/hud/GateCard.tsx
import { useRef, useMemo } from 'react';
import { Canvas, useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { clsx } from 'clsx';
import { useGameStore } from '../../../store/gameStore';
import type { GateType } from '../../../engine/core/QuantumLogic';

// ==========================================
// 3D PREVIEWS (Scaled down for depth)
// ==========================================

const InjectorPreview = () => {
  const group = useRef<THREE.Group>(null);
  const coreGeo = useMemo(() => new THREE.IcosahedronGeometry(1.0, 0), []); 
  const ringGeo = useMemo(() => new THREE.TorusGeometry(1.6, 0.08, 8, 32), []);

  useFrame((state) => {
    if (!group.current) return;
    const t = state.clock.getElapsedTime();
    group.current.rotation.x = t * 0.5;
    group.current.rotation.y = t * 0.8;
  });

  return (
    <group ref={group} scale={0.55}>
      <mesh geometry={coreGeo}>
        <meshBasicMaterial color="#00ff41" toneMapped={false} />
      </mesh>
      <mesh geometry={coreGeo} scale={1.2}>
        <meshBasicMaterial color="white" wireframe transparent opacity={0.2} />
      </mesh>
      <mesh geometry={ringGeo} rotation={[Math.PI/2, 0, 0]} scale={0.7}>
         <meshBasicMaterial color="#00ff41" transparent opacity={0.6} toneMapped={false} />
      </mesh>
      <mesh geometry={ringGeo} rotation={[0, Math.PI/2, 0]} scale={0.9}>
         <meshBasicMaterial color="#00ff41" transparent opacity={0.4} toneMapped={false} />
      </mesh>
      <mesh geometry={ringGeo} rotation={[Math.PI/4, Math.PI/4, 0]} scale={1.1}>
         <meshBasicMaterial color="#00ff41" transparent opacity={0.2} toneMapped={false} />
      </mesh>
    </group>
  );
};

const FirewallPreview = () => {
  const group = useRef<THREE.Group>(null);
  const shieldRef = useRef<THREE.Mesh>(null);
  const coreGeo = useMemo(() => new THREE.IcosahedronGeometry(0.8, 0), []);
  const shieldGeo = useMemo(() => new THREE.DodecahedronGeometry(1.8, 0), []);
  const ringGeo = useMemo(() => new THREE.TorusGeometry(1.2, 0.08, 8, 32), []);

  useFrame((state) => {
    if (!group.current || !shieldRef.current) return;
    const t = state.clock.getElapsedTime();
    shieldRef.current.rotation.y = -t * 0.2;
    shieldRef.current.rotation.z = t * 0.1;
  });

  return (
    <group ref={group} scale={0.55}>
      <mesh geometry={coreGeo}>
        <meshBasicMaterial color="#00f3ff" toneMapped={false} />
      </mesh>
      <mesh geometry={ringGeo} scale={0.6} rotation={[Math.PI/2, 0, 0]}>
         <meshBasicMaterial color="#00f3ff" toneMapped={false} />
      </mesh>
      <mesh geometry={ringGeo} scale={0.8} rotation={[0, Math.PI/2, 0]}>
         <meshBasicMaterial color="#00f3ff" toneMapped={false} />
      </mesh>
      <mesh ref={shieldRef} geometry={shieldGeo}>
        <meshBasicMaterial color="#00f3ff" wireframe transparent opacity={0.2} />
      </mesh>
    </group>
  );
};

const VirusPreview = () => {
  const group = useRef<THREE.Group>(null);
  const coreGeo = useMemo(() => new THREE.IcosahedronGeometry(0.9, 0), []);
  const shellGeo = useMemo(() => new THREE.IcosahedronGeometry(1.6, 0), []);

  useFrame((state) => {
    if (!group.current) return;
    const t = state.clock.getElapsedTime();
    group.current.children[0].rotation.x = t * 2;
    group.current.children[0].rotation.y = t;

    if (t % 0.15 < 0.02) {
       const shell = group.current.children[1];
       shell.rotation.set(Math.random()*3, Math.random()*3, 0);
       const s = 1 + Math.random() * 0.3;
       shell.scale.set(s,s,s);
    }
  });

  return (
    <group ref={group} scale={0.55}>
      <mesh geometry={coreGeo}>
        <meshBasicMaterial color="#ff0055" toneMapped={false} />
      </mesh>
      <mesh geometry={shellGeo}>
        <meshBasicMaterial color="#aa00ff" wireframe transparent opacity={0.4} toneMapped={false} />
      </mesh>
    </group>
  );
};


// ==========================================
// 2. ULTRA-CLEAR GLASS UI
// ==========================================

interface GateCardProps {
  type: GateType;
  onDragStart: (e: React.PointerEvent) => void;
}

export const GateCard = ({ type, onDragStart }: GateCardProps) => {
  const { selectedGate, draggingGate, currentPlayer, isMultiplayer, myRole } = useGameStore();
  
  const isMyTurn = isMultiplayer ? currentPlayer === myRole : currentPlayer === 'blue';
  const isSelected = selectedGate === type;
  const isDraggingThis = draggingGate === type;

  const config = useMemo(() => {
    if (type === 'Z') return { name: "FIREWALL", color: 'text-cyan-400', border: 'border-cyan-500/50', glow: 'shadow-cyan-500/50' };
    if (type === 'X') return { name: "INJECTOR", color: 'text-green-400', border: 'border-green-500/50', glow: 'shadow-green-500/50' };
    return { name: "VIRUS", color: 'text-pink-500', border: 'border-pink-500/50', glow: 'shadow-pink-500/50' };
  }, [type]);

  const handlePointerDown = (e: React.PointerEvent) => {
    e.preventDefault(); 
    if (!isMyTurn) return;
    const target = e.target as HTMLElement;
    if (target.hasPointerCapture(e.pointerId)) target.releasePointerCapture(e.pointerId);
    onDragStart(e);
  };

  return (
    <div className="relative group">
      
      {/* Top Active Line */}
      <div className={clsx(
        "absolute -top-3 left-1/2 -translate-x-1/2 w-12 h-[2px] transition-all duration-300",
        isSelected ? `bg-current ${config.color} shadow-[0_0_15px_currentColor]` : "bg-transparent"
      )} />

      <button
        onPointerDown={handlePointerDown}
        disabled={!isMyTurn}
        className={clsx(
          "relative w-28 h-40 rounded-xl overflow-hidden transition-all duration-300",
          
          // --- REAL GLASS EFFECT ---
          // 1. Almost zero background opacity (Only 5% at top gradient)
          "bg-gradient-to-b from-white/10 to-transparent",
          // 2. Medium Blur (Frosted look, not Solid look)
          "backdrop-blur-md",
          // 3. Thin, crisp borders
          "border", isSelected ? "border-white" : "border-white/20 hover:border-white/40",
          
          // --- INTERACTION STATES ---
          isDraggingThis ? "opacity-30 scale-90" : "opacity-100",
          isSelected ? `scale-105 -translate-y-2 shadow-2xl ${config.glow}` : "hover:-translate-y-1 hover:shadow-lg",
          !isMyTurn && "opacity-30 grayscale cursor-not-allowed border-dashed"
        )}
      >
        
        {/* SCANLINE (Faint) */}
        <div className="absolute inset-0 bg-[url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0IiBoZWlnaHQ9IjQiPgo8cmVjdCB3aWR0aD0iNCIgaGVpZ2h0PSI0IiBmaWxsPSIjMDAwMDAwIi8+CjxyZWN0IHdpZHRoPSI0IiBoZWlnaHQ9IjEiIGZpbGw9InJnYmEoMjU1LDI1NSwyNTUsMC4wNSkiLz4KPC9zdmc+')] opacity-10 pointer-events-none z-0" />

        {/* 3D CONTENT */}
        <div className="absolute inset-0 z-0">
            <Canvas gl={{ alpha: true, antialias: true }} camera={{ position: [0, 0, 5], fov: 45 }}>
                <ambientLight intensity={0.5} />
                <pointLight position={[5, 2, 5]} intensity={10} />
                {type === 'Z' && <FirewallPreview />}
                {type === 'X' && <InjectorPreview />}
                {type === 'H' && <VirusPreview />}
            </Canvas>
        </div>

        {/* ID (Watermark style) */}
        <div className="absolute top-2 left-3 z-10 pointer-events-none">
            <span className={clsx("text-4xl font-black opacity-20 select-none", config.color)}>{type}</span>
        </div>

        {/* NAME BADGE (Floating Glass Pill) */}
        <div className="absolute bottom-3 w-full flex justify-center z-10 pointer-events-none">
            <div className={clsx(
                "px-3 py-1 rounded-full backdrop-blur-md shadow-lg border border-white/10",
                "bg-black/30" // Slight tint for readability
            )}>
                <span className={clsx("text-[9px] font-black tracking-widest block", config.color)}>
                    {config.name}
                </span>
            </div>
        </div>

      </button>
    </div>
  );
};
--- END OF FILE: src\components\dom\hud\GateCard.tsx ---


--- START OF FILE: src\components\dom\ui\Loader.tsx ---
// src/components/dom/ui/Loader.tsx
import { motion } from 'framer-motion';

export const Loader = ({ message = "SYSTEM INITIALIZING" }: { message?: string }) => {
  return (
    <div className="fixed inset-0 z-[9999] bg-black flex flex-col items-center justify-center cursor-wait">
      {/* Background Pulse */}
      <div className="absolute inset-0 bg-neon-blue/5 animate-pulse" />
      
      {/* Spinner */}
      <div className="relative w-24 h-24 mb-8">
        {/* Outer Ring */}
        <div className="absolute inset-0 border-4 border-gray-800 rounded-full" />
        {/* Spinning Segment */}
        <motion.div 
          className="absolute inset-0 border-4 border-t-neon-blue border-r-transparent border-b-transparent border-l-transparent rounded-full"
          animate={{ rotate: 360 }}
          transition={{ duration: 1, repeat: Infinity, ease: "linear" }}
        />
        {/* Inner Counter-Spin */}
        <motion.div 
          className="absolute inset-2 border-4 border-t-transparent border-r-neon-pink border-b-transparent border-l-transparent rounded-full"
          animate={{ rotate: -360 }}
          transition={{ duration: 1.5, repeat: Infinity, ease: "linear" }}
        />
      </div>

      {/* Text */}
      <div className="flex flex-col items-center gap-2">
        <h2 className="text-xl font-black text-white tracking-[0.3em] animate-pulse">
          {message}
        </h2>
        <div className="flex gap-1">
          <span className="w-2 h-2 bg-neon-blue rounded-full animate-bounce" style={{ animationDelay: '0s' }}/>
          <span className="w-2 h-2 bg-neon-blue rounded-full animate-bounce" style={{ animationDelay: '0.1s' }}/>
          <span className="w-2 h-2 bg-neon-blue rounded-full animate-bounce" style={{ animationDelay: '0.2s' }}/>
        </div>
      </div>

      {/* Footer */}
      <div className="absolute bottom-8 text-[10px] text-gray-500 font-mono">
        ENCRYPTING DATA STREAM // DO NOT TURN OFF
      </div>
    </div>
  );
};
--- END OF FILE: src\components\dom\ui\Loader.tsx ---


--- START OF FILE: src\components\dom\ui\logo.tsx ---
// src/components/dom/ui/Logo.tsx
import { useRef, useMemo } from 'react';
import { Canvas, useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import { motion } from 'framer-motion';

// --- 3D COMPONENT ---
const LogoCrystal = () => {
  const groupRef = useRef<THREE.Group>(null);
  const lightsRef = useRef<THREE.Group>(null);
  
  const coreRef = useRef<THREE.Mesh>(null);
  const ring1Ref = useRef<THREE.Mesh>(null); 
  const ring2Ref = useRef<THREE.Mesh>(null); 
  const ring3Ref = useRef<THREE.Mesh>(null); 

  const coreGeo = useMemo(() => new THREE.IcosahedronGeometry(1.2, 1), []); // Detail 1 for smoother lighting
  const ringGeo = useMemo(() => new THREE.TorusGeometry(1.8, 0.06, 8, 48), []);

  useFrame((state) => {
    if (!groupRef.current || !lightsRef.current) return;
    const t = state.clock.getElapsedTime();
    const mouse = state.mouse;

    // 1. ROTATE LIGHTS (The Color Shift Logic)
    // The lights orbit the center, causing the "Blue" and "Red" sides to move
    lightsRef.current.rotation.y = t * 0.8;
    lightsRef.current.rotation.z = Math.sin(t * 0.5) * 0.5;

    // 2. CRYSTAL ANIMATION
    if(coreRef.current) {
        coreRef.current.rotation.y = -t * 0.2; // Counter-rotate core
        coreRef.current.rotation.x = t * 0.1;
    }
    
    // Rings Animation
    if(ring1Ref.current) {
        ring1Ref.current.rotation.x = t * 0.8;
        ring1Ref.current.rotation.y = t * 0.2;
    }
    if(ring2Ref.current) {
        ring2Ref.current.rotation.x = -t * 0.3;
        ring2Ref.current.rotation.y = -t * 0.7;
    }
    if(ring3Ref.current) {
        ring3Ref.current.rotation.z = t * 0.4;
        ring3Ref.current.rotation.x = Math.sin(t * 0.5) * 0.3;
    }

    // 3. PARALLAX
    groupRef.current.rotation.x = THREE.MathUtils.lerp(groupRef.current.rotation.x, mouse.y * 0.4, 0.1);
    groupRef.current.rotation.y = THREE.MathUtils.lerp(groupRef.current.rotation.y, mouse.x * 0.4, 0.1);
  });

  return (
    <group>
        
      {/* --- DUAL LIGHT RIG (Rotating) --- */}
      <group ref={lightsRef}>
          {/* Blue Army */}
          <pointLight position={[-8, 0, 0]} intensity={20} color="#0088ff" distance={15} scale={200} />
          {/* Red Army */}
          <pointLight position={[8, 0, 0]} intensity={20} color="#ff0055" distance={15} scale={200} />
      </group>

      <group ref={groupRef}>
        {/* --- CORE (The Battlefield) --- */}
        <mesh ref={coreRef} geometry={coreGeo}>
            {/* 
                High roughness = Diffuse light blending. 
                White color = Reflects the colored lights exactly.
            */}
            <meshStandardMaterial 
                color="#cccccc" 
                roughness={0.4} 
                metalness={0.8} 
            />
        </mesh>
        
        {/* Wireframe Overlay */}
        <mesh geometry={coreGeo} scale={1.02}>
            <meshBasicMaterial color="white" wireframe transparent opacity={0.1} />
        </mesh>

        {/* --- RINGS --- */}
        <mesh ref={ring1Ref} geometry={ringGeo} scale={0.7}>
            <meshBasicMaterial color="#00f3ff" transparent opacity={0.6} toneMapped={false} />
        </mesh>

        <mesh ref={ring2Ref} geometry={ringGeo} scale={0.9}>
            <meshBasicMaterial color="#ff0055" transparent opacity={0.6} toneMapped={false} />
        </mesh>

        <mesh ref={ring3Ref} geometry={ringGeo} scale={1.1}>
            <meshBasicMaterial color="#ffffff" transparent opacity={0.3} toneMapped={false} />
        </mesh>
      </group>

    </group>
  );
};

// --- MAIN COMPONENT ---
export const Logo = ({ scale = 1.0 }: { scale?: number }) => {
  return (
    <div className="relative flex flex-col items-center justify-center select-none" style={{ transform: `scale(${scale})` }}>
      
      {/* 3D LAYER */}
      <div className="absolute inset-0 w-80 h-80 -translate-x-1/2 left-1/2 -top-20 z-0 pointer-events-none">
        <Canvas gl={{ alpha: true, antialias: true }} camera={{ position: [0, 0, 6], fov: 45 }}>
            <LogoCrystal />
        </Canvas>
      </div>

      {/* TEXT LAYER */}
      <div className="relative z-10 text-center"> 
        <h1 className="text-6xl md:text-7xl font-black text-white tracking-tighter drop-shadow-[0_4px_8px_rgba(0,0,0,1)]">
          QUANTUM
        </h1>
        
        <div className="text-xl md:text-2xl font-bold tracking-[0.6em] mt-[-5px] bg-black/40 backdrop-blur-md px-4 rounded border border-white/10 shadow-lg">
          <span className="text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 via-white to-pink-500 drop-shadow-md">
            BREACH
          </span>
        </div>
      </div>

      {/* LINE */}
      <motion.div 
        initial={{ width: 0, opacity: 0 }}
        animate={{ width: "100%", opacity: 1 }}
        transition={{ delay: 0.5, duration: 0.8 }}
        className="h-px bg-gradient-to-r from-transparent via-white/30 to-transparent mt-6 w-32"
      />
      
    </div>
  );
};
--- END OF FILE: src\components\dom\ui\logo.tsx ---


--- START OF FILE: src\engine\ai\minimax.worker.ts ---
// src/engine/ai/minimax.worker.ts
import { type GateType, GRID_SIZE } from '../core/QuantumLogic';

// ==========================================
// PART 1: CONSTANTS & STATIC CACHES
// ==========================================

// --- 1.1 POSITION HEATMAP (Strategy) ---
// Higher numbers = more valuable territory (Center control is key)
const POSITION_VALUES = new Int8Array([
  2,  3,  4,  4,  3,  2,
  3,  6,  8,  8,  6,  3,
  4,  8, 12, 12,  8,  4,
  4,  8, 12, 12,  8,  4,
  3,  6,  8,  8,  6,  3,
  2,  3,  4,  4,  3,  2
]);

// --- 1.2 OPENING BOOK (Knowledge) ---
// Pre-calculated strong openings for high-difficulty AI (Red Player)
// Indexed by total moves on board (0, 1, 2...)
const OPENING_BOOK: Record<number, { id: number, gate: GateType }> = {
  // If Blue starts, Red responds:
  1: { id: 20, gate: 'Z' }, // Lock center-right immediately if available
  3: { id: 14, gate: 'X' }, // Aggressive center-left take
};
// --- HELPER: Random Shuffle for "Blind" AI ---
const shuffleArray = (array: number[]) => {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
};

// <--- INSERT THE MISSING FUNCTION HERE --->
const getOpeningMove = (turns: number, difficulty: number): { id: number, gate: GateType } | null => {
  if (difficulty < 5) return null;
  return OPENING_BOOK[turns] || null;
};

// --- 1.3 NEIGHBOR CACHING (Performance) ---
const NEIGHBORS_CACHE = new Int16Array(36 * 8); 
const IS_DIAG_CACHE = new Uint8Array(36 * 8);   

(() => {
  const dirs = [
    { dx: 0, dy: 1, diag: 0 }, { dx: 0, dy: -1, diag: 0 }, // Orthogonal
    { dx: 1, dy: 0, diag: 0 }, { dx: -1, dy: 0, diag: 0 },
    { dx: 1, dy: 1, diag: 1 }, { dx: 1, dy: -1, diag: 1 }, // Diagonal
    { dx: -1, dy: 1, diag: 1 }, { dx: -1, dy: -1, diag: 1 }
  ];
  NEIGHBORS_CACHE.fill(-1);
  for (let i = 0; i < 36; i++) {
    const x = Math.floor(i / GRID_SIZE);
    const y = i % GRID_SIZE;
    dirs.forEach((d, idx) => {
      const nx = x + d.dx;
      const ny = y + d.dy;
      if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
        NEIGHBORS_CACHE[i * 8 + idx] = nx * GRID_SIZE + ny;
        IS_DIAG_CACHE[i * 8 + idx] = d.diag;
      }
    });
  }
})();

// ==========================================
// PART 2: CORE SIMULATION LOGIC
// ==========================================

/**
 * Counts non-empty cells to determine game phase.
 */
const countMoves = (board: Int8Array): number => {
  let count = 0;
  for(let i=0; i<36; i++) if(board[i] !== 0) count++;
  return count;
};

/**
 * Fast checking of neighbor counts for evaluation clustering.
 */
const countFriendlyNeighbors = (board: Int8Array, idx: number, owner: number): number => {
  let count = 0;
  for (let k = 0; k < 8; k++) {
    const nIdx = NEIGHBORS_CACHE[idx * 8 + k];
    if (nIdx !== -1 && Math.sign(board[nIdx]) === owner) count++;
  }
  return count;
};

/**
 * Byte-level move application.
 * Returns a NEW Int8Array representing the board state after the move.
 */
const applyMoveFast = (board: Int8Array, idx: number, gate: number, isBlue: boolean): Int8Array => {
  const next = new Int8Array(board); 
  const me = isBlue ? 1 : -1;
  const enemy = -me;

  // GATE CODES: 1=Z (Lock), 2=X (Collider), 3=H (Virus/Entropy)
  
  // 1. PRIMARY EFFECT
  if (gate === 1) { next[idx] = 2 * me; return next; } // Z: Locked (No neighbor effects)
  if (gate === 2) { next[idx] = 1 * me; } // X: Stable
  if (gate === 3) { next[idx] = 3 * me; } // H: Flux

  // 2. NEIGHBOR EFFECTS
  for (let k = 0; k < 8; k++) {
    const nIdx = NEIGHBORS_CACHE[idx * 8 + k];
    if (nIdx === -1) continue;
    
    const val = next[nIdx];
    if (val === 0 || Math.abs(val) === 2) continue; // Skip Empty or Locked

    const isDiag = IS_DIAG_CACHE[idx * 8 + k] === 1;

    // --- COLLIDER (X) ---
    if (gate === 2) {
      if (isDiag) continue; // AI Assumption: Diagonals always fail (Risk Aversion)
      
      // Capture Enemy Stable
      if (val === 1 * enemy) next[nIdx] = 1 * me;
      // Stabilize Flux (Neutral or Enemy)
      else if (Math.abs(val) === 3) next[nIdx] = 1 * me;
    }
    
    // --- VIRUS (H) ---
    else if (gate === 3) {
      // Destabilize Enemy Stable -> Flux
      if (val === 1 * enemy) next[nIdx] = 3 * me;
      // Steal Flux Control
      else if (Math.abs(val) === 3) next[nIdx] = 3 * me;
    }
  }

  return next;
};
// ==========================================
// PART 3: ADVANCED EVALUATION (HEURISTICS)
// ==========================================

/**
 * Calculates strategic threats.
 * Penalizes the AI if the enemy has created strong, connected clusters.
 */
const evaluateThreats = (board: Int8Array, me: number): number => {
  let threatScore = 0;
  const enemy = -me;
  
  for (let i = 0; i < 36; i++) {
    // Only look at enemy pieces
    if (Math.sign(board[i]) !== enemy) continue;
    
    // Check how fortified this enemy piece is
    const connections = countFriendlyNeighbors(board, i, enemy);
    
    // 3+ connections = Strong Cluster (Hard to penetrate)
    if (connections >= 3) threatScore -= 20; 
    // 5+ connections = Fortress (Very bad for us)
    if (connections >= 5) threatScore -= 40;
  }
  
  return threatScore;
};

/**
 * The brain of the AI. Determines how "good" a specific board state is.
 * Returns a score relative to 'me' (Higher is better).
 */
const evaluateAdvanced = (board: Int8Array, me: number): number => {
  let score = 0;
  
  for (let i = 0; i < 36; i++) {
    const val = board[i];
    if (val === 0) continue;
    
    const owner = Math.sign(val);
    const type = Math.abs(val); // 1=Stable, 2=Locked, 3=Flux
    
    // --- 1. MATERIAL SCORE ---
    let cellValue = 0;
    
    // Locked cells are permanent points, highly valuable
    if (type === 2) cellValue = 80; 
    // Stable cells are standard value
    else if (type === 1) cellValue = 25; 
    // Flux is risky/weak (could flip to enemy)
    else if (type === 3) cellValue = 10; 
    
    // --- 2. POSITIONAL SCORE ---
    // Add bonus based on heatmap (Center is worth more)
    cellValue += POSITION_VALUES[i] * 3;

    // --- 3. CLUSTERING SCORE ---
    // Bonus for protecting our own pieces
    const neighbors = countFriendlyNeighbors(board, i, owner);
    cellValue += neighbors * 6;

    // Apply score to owner
    if (owner === me) score += cellValue;
    else score -= cellValue;
  }
  
  // --- 4. THREAT ADJUSTMENT ---
  score += evaluateThreats(board, me);
  
  // --- 5. MOBILITY/AGENCY ---
  // If we are winning, push harder. If losing, take risks.
  // (Simplified as raw score usually handles this)

  return score;
};

// ==========================================
// PART 4: MOVE ORDERING
// ==========================================

/**
 * Sorts potential moves to maximize Alpha-Beta pruning efficiency.
 * We want to check the "best" moves first so we can discard bad branches early.
 */
const orderMoves = (board: Int8Array, moves: number[]): number[] => {
  return moves.sort((a, b) => {
    // 1. Prioritize Center (Heatmap)
    const scoreA = POSITION_VALUES[a];
    const scoreB = POSITION_VALUES[b];
    
    // 2. Prioritize moves next to existing pieces (Attack/Defend potential)
    // We check if the cell has ANY neighbors (friend or foe)
    let neighborsA = 0;
    let neighborsB = 0;
    
    for(let k=0; k<8; k++) {
        if(NEIGHBORS_CACHE[a*8+k] !== -1 && board[NEIGHBORS_CACHE[a*8+k]] !== 0) neighborsA++;
        if(NEIGHBORS_CACHE[b*8+k] !== -1 && board[NEIGHBORS_CACHE[b*8+k]] !== 0) neighborsB++;
    }

    // Sort descending: Higher score + more neighbors = check first
    return (scoreB + neighborsB * 2) - (scoreA + neighborsA * 2);
  });
};
// ==========================================
// PART 5: MINIMAX ALGORITHM
// ==========================================

const minimax = (
  board: Int8Array, 
  depth: number, 
  alpha: number, 
  beta: number, 
  isMaximizing: boolean, 
  rootPlayerSign: number,
  allowedGates: number[]
): number => {
  // 1. BASE CASE: Leaf node or Terminal state
  // We check for game over by seeing if board is full (no 0s)
  // Optimization: Just check depth first as it's cheaper
  if (depth === 0) {
    return evaluateAdvanced(board, rootPlayerSign);
  }

  // Check if board is full (Endgame)
  let emptyFound = false;
  for(let i=0; i<36; i++) { if(board[i] === 0) { emptyFound = true; break; } }
  if (!emptyFound) return evaluateAdvanced(board, rootPlayerSign);

  const currentPlayerIsBlue = isMaximizing ? (rootPlayerSign === 1) : (rootPlayerSign !== 1);

  // 2. MOVE GENERATION
  // Find all empty cells
  let moves: number[] = [];
  for(let i=0; i<36; i++) if(board[i] === 0) moves.push(i);

  // Optimization: Order moves to prune bad branches early
  moves = orderMoves(board, moves);

  // 3. RECURSION
  if (isMaximizing) {
    let maxEval = -Infinity;
    
    for (const id of moves) {
      for (const gate of allowedGates) {
        // Apply move
        const nextBoard = applyMoveFast(board, id, gate, currentPlayerIsBlue);
        
        // Recurse
        const evalScore = minimax(nextBoard, depth - 1, alpha, beta, false, rootPlayerSign, allowedGates);
        
        maxEval = Math.max(maxEval, evalScore);
        alpha = Math.max(alpha, evalScore);
        
        // Prune
        if (beta <= alpha) break; 
      }
      if (beta <= alpha) break;
    }
    return maxEval;

  } else {
    let minEval = Infinity;
    
    for (const id of moves) {
      for (const gate of allowedGates) {
        const nextBoard = applyMoveFast(board, id, gate, currentPlayerIsBlue);
        
        const evalScore = minimax(nextBoard, depth - 1, alpha, beta, true, rootPlayerSign, allowedGates);
        
        minEval = Math.min(minEval, evalScore);
        beta = Math.min(beta, evalScore);
        
        if (beta <= alpha) break;
      }
      if (beta <= alpha) break;
    }
    return minEval;
  }
};

// ==========================================
// PART 6: SEARCH ORCHESTRATOR
// ==========================================

const searchBestMove = (
  board: Int8Array, 
  isBlue: boolean, 
  depth: number, 
  gateTypes: GateType[],
  scanLimit: number = 36, // NEW: How many cells to look at (Blindness)
  randomize: boolean = false // NEW: If true, ignore strategic sorting
) => {
  const me = isBlue ? 1 : -1;
  const allowedCodes = gateTypes.map(g => g === 'Z' ? 1 : g === 'X' ? 2 : 3);
  
  let bestScore = -Infinity;
  let bestMove = { id: -1, gate: gateTypes[0] }; 

  // 1. Get Moves
  let moves: number[] = [];
  for(let i=0; i<36; i++) if(board[i] === 0) moves.push(i);

  // 2. INTELLIGENCE FILTER
  if (randomize) {
    // DUMB AI: Shuffle moves randomly (doesn't know what's good)
    moves = shuffleArray(moves);
  } else {
    // SMART AI: Sort moves by strategy (Heatmap/Threats)
    moves = orderMoves(board, moves);
  }

  // 3. BLINDNESS FILTER
  // Only look at the first N moves.
  // If randomized, this means looking at N random spots on the board.
  const candidates = moves.slice(0, scanLimit);

  // 4. Evaluate Candidates
  for (const id of candidates) {
    for (const gateCode of allowedCodes) {
      const gateName = gateTypes[allowedCodes.indexOf(gateCode)];

      // Apply
      const nextBoard = applyMoveFast(board, id, gateCode, isBlue);
      
      // Call Minimax
      const score = minimax(nextBoard, depth - 1, -Infinity, Infinity, false, me, allowedCodes);

      // Update Best
      if (score > bestScore || (score === bestScore && Math.random() > 0.8)) {
        bestScore = score;
        bestMove = { id, gate: gateName };
      }
    }
  }

  // Fallback: If no move found (rare edge case with limits), pick first valid
  if (bestMove.id === -1 && moves.length > 0) {
    bestMove = { id: moves[0], gate: gateTypes[0] };
  }

  return bestMove;
};
// ==========================================
// PART 7: DIFFICULTY CONFIGURATION
// ==========================================

const findBestMove = (board: Int8Array, isBlue: boolean, difficulty: number) => {
  const currentTurn = countMoves(board);
  
  // --- LEVEL 1: BRAINLESS ---
  // Scans 1 random cell. Effectively pure RNG.
  if (difficulty <= 1) {
    return searchBestMove(board, isBlue, 1, ['X'], 1, true); 
  }

  // --- LEVEL 2: ROOKIE ---
  // Scans 3 random cells. Might find a capture, likely misses it.
  if (difficulty <= 2) {
    return searchBestMove(board, isBlue, 1, ['X'], 3, true); 
  }

  // --- LEVEL 3: BEGINNER ---
  // Scans 6 random cells. Sees ~20% of the board.
  if (difficulty <= 3) {
    return searchBestMove(board, isBlue, 1, ['X', 'Z'], 6, true); 
  }

  // --- LEVEL 4: AMATEUR ---
  // Scans 12 cells (33% of board). Depth 2.
  // Starts seeing threats but still makes positional mistakes.
  if (difficulty <= 4) {
    return searchBestMove(board, isBlue, 2, ['X', 'Z'], 12, true); 
  }

  // --- LEVEL 5-6: MEDIUM (Standard) ---
  // Sees everything (36), Strategy ON (False flag), Depth 3.
  if (difficulty <= 6) {
    const opening = getOpeningMove(currentTurn, difficulty);
    if (opening) return opening;
    return searchBestMove(board, isBlue, 3, ['X', 'Z', 'H'], 36, false);
  }

  // --- LEVEL 7-8: HARD ---
  // Depth 4 + Adaptive
  if (difficulty <= 8) {
    const opening = getOpeningMove(currentTurn, difficulty);
    if (opening) return opening;
    
    const emptyCount = 36 - currentTurn;
    const depth = emptyCount < 10 ? 5 : 4;

    return searchBestMove(board, isBlue, depth, ['X', 'Z', 'H'], 36, false);
  }

  // --- LEVEL 9-10: NIGHTMARE ---
  // Max Depth
  const opening = getOpeningMove(currentTurn, difficulty);
  if (opening) return opening;
  
  const emptyCount = 36 - currentTurn;
  const depth = emptyCount < 8 ? 6 : 4; 
  
  return searchBestMove(board, isBlue, depth, ['X', 'Z', 'H'], 36, false);
};

// ==========================================
// PART 8: WORKER INTERFACE
// ==========================================

self.onmessage = (e: MessageEvent) => {
  const { board, player, difficulty } = e.data;
  
  // Cast raw buffer to TypedArray
  const byteBoard = board as Int8Array;
  const isBlue = player === 'blue';

  try {
    const start = Date.now();
    
    // 1. Compute Move
    const bestMove = findBestMove(byteBoard, isBlue, difficulty);
    
    // 2. Simulate "Thinking" Time
    // Higher difficulty = Artificial delay to simulate "deep thought"
    // This adds tension to the game UI
    const elapsed = Date.now() - start;
    const minDelay = 400 + (difficulty * 100); // 500ms to 1.5s
    
    const remainingDelay = Math.max(0, minDelay - elapsed);

    setTimeout(() => {
        postMessage(bestMove);
    }, remainingDelay);

  } catch (err) {
    console.error("AI CRITICAL FAILURE:", err);
    // Fallback: Return first available move to prevent crash
    for(let i=0; i<36; i++) {
        if(byteBoard[i] === 0) {
            postMessage({ id: i, gate: 'X' });
            break;
        }
    }
  }
};
--- END OF FILE: src\engine\ai\minimax.worker.ts ---


--- START OF FILE: src\engine\core\GeometryManager.ts ---
// src/engine/core/GeometryManager.ts
import * as THREE from 'three';

class GeometryManagerImpl {
  private geometries = new Map<string, THREE.BufferGeometry>();
  private materials = new Map<string, THREE.Material>();

  /**
   * Get or create a geometry.
   * @param key Unique identifier for the geometry
   * @param factory Function that returns the geometry if it doesn't exist
   */
  getGeometry<T extends THREE.BufferGeometry>(key: string, factory: () => T): T {
    if (!this.geometries.has(key)) {
      this.geometries.set(key, factory());
    }
    return this.geometries.get(key) as T;
  }

  /**
   * Get or create a material.
   * @param key Unique identifier for the material
   * @param factory Function that returns the material if it doesn't exist
   */
  getMaterial<T extends THREE.Material>(key: string, factory: () => T): T {
    if (!this.materials.has(key)) {
      this.materials.set(key, factory());
    }
    return this.materials.get(key) as T;
  }

  /**
   * Dispose all resources to free GPU memory.
   * Call this when exiting the game session.
   */
  dispose() {
    this.geometries.forEach((geo) => geo.dispose());
    this.materials.forEach((mat) => mat.dispose());
    
    this.geometries.clear();
    this.materials.clear();
    
    // Corrected for Vite
    if (import.meta.env.DEV) {
      console.log('โป๏ธ GeometryManager: All resources disposed.');
    }
  }
}

export const GeometryManager = new GeometryManagerImpl();
--- END OF FILE: src\engine\core\GeometryManager.ts ---


--- START OF FILE: src\engine\core\QuantumLogic.ts ---
// src/engine/core/QuantumLogic.ts

export type Player = 'blue' | 'red' | null;
export type CellStatus = 'STABLE' | 'LOCKED' | 'FLUX';
export type GateType = 'Z' | 'X' | 'H';

export interface Qubit {
  id: number;
  x: number;
  y: number;
  owner: Player;
  status: CellStatus | null;
  fluxOwner: Player;
}

export const GRID_SIZE = 6;
export const TOTAL_CELLS = 36;

// --- 1. DETERMINISTIC RANDOM (PRNG) ---
// Critical for Multiplayer Sync: Both clients must generate the exact same "random" numbers
// given the same seed.
export const mulberry32 = (a: number) => {
  return () => {
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  }
};

export const createInitialBoard = (): Qubit[] => {
  return Array.from({ length: TOTAL_CELLS }, (_, i) => ({
    id: i,
    x: Math.floor(i / GRID_SIZE),
    y: i % GRID_SIZE,
    owner: null,
    status: null,
    fluxOwner: null
  }));
};

const getIdx = (x: number, y: number) => {
  if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return -1;
  return x * GRID_SIZE + y;
};

// --- CORE LOGIC ---

export const applyQuantumMove = (
  currentBoard: Qubit[],
  targetId: number,
  gate: GateType,
  activePlayer: Player,
  seed?: number
): Qubit[] => {
  // Clone board to avoid mutation side-effects
  const board = currentBoard.map(q => ({ ...q }));
  const centerNode = board[targetId];

  if (!centerNode || centerNode.status !== null) return currentBoard;

  // Initialize PRNG if seed provided, else fallback to Math.random (Local play without seed)
  const random = seed !== undefined ? mulberry32(seed) : Math.random;

  const enemy = activePlayer === 'blue' ? 'red' : 'blue';

  // 1. PRIMARY EFFECT (The clicked cell)
  if (gate === 'Z') {
    centerNode.status = 'LOCKED';
    centerNode.owner = activePlayer;
    return board; // Observer has no neighbors
  }
  else if (gate === 'X') {
    centerNode.status = 'STABLE';
    centerNode.owner = activePlayer;
  }
  else if (gate === 'H') {
    centerNode.status = 'FLUX';
    centerNode.owner = null;
    centerNode.fluxOwner = activePlayer;
  }

  // 2. SECONDARY EFFECTS (Neighbors)
  const cx = centerNode.x;
  const cy = centerNode.y;

  const neighbors = [
    // ORTHOGONAL (Zone 1) - Guaranteed Hit
    { dx: 0, dy: 1, isDiag: false },
    { dx: 0, dy: -1, isDiag: false },
    { dx: 1, dy: 0, isDiag: false },
    { dx: -1, dy: 0, isDiag: false },
    // DIAGONAL (Zone 2) - 50% Chance
    { dx: 1, dy: 1, isDiag: true },
    { dx: 1, dy: -1, isDiag: true },
    { dx: -1, dy: 1, isDiag: true },
    { dx: -1, dy: -1, isDiag: true }
  ];

  for (const { dx, dy, isDiag } of neighbors) {
    const idx = getIdx(cx + dx, cy + dy);
    if (idx === -1) continue;

    const target = board[idx];
    if (target.status === null || target.status === 'LOCKED') continue;

    // GATE LOGIC
    if (gate === 'X') {
      // Collider: 50% chance to fail on diagonals
      if (isDiag && random() > 0.5) continue;

      if (target.status === 'STABLE' && target.owner === enemy) {
        target.owner = activePlayer; // Capture
      }
      else if (target.status === 'FLUX') {
        target.status = 'STABLE';
        target.owner = activePlayer; // Stabilize
        target.fluxOwner = null;
      }
    }
    else if (gate === 'H') {
      // Entropy: Always hits neighbors (Chaos)
      if (target.status === 'STABLE' && target.owner === enemy) {
        target.status = 'FLUX';
        target.owner = null;
        target.fluxOwner = activePlayer;
      }
      else if (target.status === 'FLUX') {
        target.fluxOwner = activePlayer; // Steal Flux Control
      }
    }
  }

  return board;
};

export const collapseBoard = (currentBoard: Qubit[], seed?: number): Qubit[] => {
  const random = seed !== undefined ? mulberry32(seed) : Math.random;

  return currentBoard.map(q => {
    if (q.status === 'FLUX') {
      // 50/50 Collapse
      const winner = random() > 0.5 ? 'blue' : 'red';
      return {
        ...q,
        status: 'STABLE',
        owner: winner,
        fluxOwner: null
      };
    }
    return q;
  });
};

// --- UTILS ---

export const calculateScore = (board: Qubit[]) => {
  let blue = 0;
  let red = 0;
  for (let i = 0; i < board.length; i++) {
    if (board[i].owner === 'blue') blue++;
    if (board[i].owner === 'red') red++;
  }
  return { blue, red };
};

export const isBoardFull = (board: Qubit[]): boolean => {
  for (let i = 0; i < board.length; i++) {
    if (board[i].status === null) return false;
  }
  return true;
};
--- END OF FILE: src\engine\core\QuantumLogic.ts ---


--- START OF FILE: src\pages\GameGuide.tsx ---
// src/pages/GameGuide.tsx
import { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Link } from 'react-router-dom';
import { clsx } from 'clsx';

type Lang = 'en' | 'fa';

// --- DATA CONTENT (Unchanged) ---
const CONTENT = {
  en: {
    title: "BREACH PROTOCOL",
    subtitle: "HACKER'S MANUAL // V.1.0",
    sections: [
      {
        id: "mission",
        title: "THE MISSION",
        color: "white",
        body: "You are attempting to breach a Quantum Core protected by an advanced AI. The goal is simple: You must occupy more bits than the AI when the system collapses.",
        footer: "Blue = Hacker (You) | Red = AI Security"
      },
      {
        id: "arsenal",
        title: "YOUR TOOLS",
        color: "#00f3ff",
        body: "You have 3 programs to upload. Drag and drop them onto the grid.",
        cards: [
          { 
            name: "INJECTOR (X)", 
            role: "ATTACK", 
            desc: "Captures a node and attacks neighbors (Up/Down/Left/Right).", 
            note: "Risk: 50% fail rate on diagonals.",
            color: "text-neon-green",
            border: "border-neon-green",
            bg: "bg-neon-green/10"
          },
          { 
            name: "FIREWALL (Z)", 
            role: "DEFEND", 
            desc: "Permanently LOCKS a node. It cannot be stolen or changed.", 
            note: "Use to secure key territory.",
            color: "text-neon-blue",
            border: "border-neon-blue",
            bg: "bg-neon-blue/10"
          },
          { 
            name: "VIRUS (H)", 
            role: "CHAOS", 
            desc: "Destabilizes a node into FLUX. It spreads chaos to all 8 neighbors.", 
            note: "High risk, high reward.",
            color: "text-neon-pink",
            border: "border-neon-pink",
            bg: "bg-neon-pink/10"
          }
        ]
      },
      {
        id: "entropy",
        title: "SYSTEM ENTROPY",
        color: "#aa00ff",
        body: "Every move increases System Instability. When the grid is full, the Core Collapses. All 'Virus' (Flux) nodes will instantly resolve to either YOU or the AI based on probability."
      },
      {
        id: "outcomes",
        title: "FINAL OUTCOMES",
        color: "gray",
        body: "When the dust settles, the score is calculated:",
        states: [
          { label: "VICTORY", text: "SYSTEM OVERRIDDEN. ACCESS GRANTED.", color: "text-neon-blue" },
          { label: "DEFEAT", text: "INTRUSION DETECTED. NEURAL LINK SEVERED.", color: "text-neon-pink" },
          { label: "DRAW (EQUAL)", text: "โ CRITICAL FAILURE. CORE MELTDOWN IMMINENT. EVACUATE IMMEDIATELY.", color: "text-yellow-400" }
        ]
      }
    ],
    back: "INITIATE UPLINK"
  },
  fa: {
title: "ูพุฑูุชฺฉู ูููุฐ",
subtitle: "ุฑุงูููุง ูฺฉุฑ // ูุณุฎู ฑ.ฐ",
sections: [
{
id: "mission",
title: "ูุงููุฑุช",
color: "white",
body: "ุดูุง ุฏุฑ ุญุงู ุชูุงุด ุจุฑุง ูููุฐ ุจู ฺฉ ูุณุชู ฺฉูุงูุชูู ูุณุชุฏ ฺฉู ุชูุณุท ููุด ูุตููุน ูพุดุฑูุชู ูุญุงูุธุช ูโุดูุฏ. ูุฏู ุณุงุฏู ุงุณุช: ุจุงุฏ ููฺฏุงู ูุฑููพุงุด ฺฉุฑุฏู ุณุณุชูุ ุจุช ูุง ุจุดุชุฑ ูุณุจุช ุจู ููุด ูุตููุน ุงุดุบุงู ฺฉุฑุฏู ุจุงุดุฏ.",
footer: "ุขุจ = ูฺฉุฑ (ุดูุง) | ูุฑูุฒ = ุงููุช ููุด ูุตููุน"
},
{
id: "arsenal",
title: "ุงุจุฒุงุฑ ูุง ุดูุง",
color: "#00f3ff",
body: "ุดูุง ณ ุจุฑูุงูู ุจุฑุง ุขูพููุฏ ุฏุฑ ุงุฎุชุงุฑ ุฏุงุฑุฏ. ุขูโูุง ุฑุง ุจฺฉุดุฏ ู ุฑู ุดุจฺฉู ุฑูุง ฺฉูุฏ.",
cards: [
{
name: "ุชุฒุฑูโฺฏุฑ (X)",
role: "ูุฌูู",
desc: "ฺฉ ุฎุงูู ุฑุง ุชุณุฎุฑ ฺฉุฑุฏู ู ุจู ููุณุงฺฏุงู (ุจุงูุง/ูพุงู/ฺูพ/ุฑุงุณุช) ุญููู ูโฺฉูุฏ.",
note: "ุฑุณฺฉ: ตฐูช ุงุญุชูุงู ุดฺฉุณุช ุฏุฑ ุฎุงููโูุง ูุทุฑ.",
color: "text-neon-green",
border: "border-neon-green",
bg: "bg-neon-green/10"
},
{
name: "ูุงุฑูุงู (Z)",
role: "ุฏูุงุน",
desc: "ฺฉ ุฎุงูู ุฑุง ุจุฑุง ููุดู ููู ูโฺฉูุฏ. ุงู ุฎุงูู ูุงุจู ุฏุฒุฏุฏู ุง ุชุบุฑ ูุณุช.",
note: "ุจุฑุง ุญูุธ ูููุฑููุง ฺฉูุฏ ุงุณุชูุงุฏู ฺฉูุฏ.",
color: "text-neon-blue",
border: "border-neon-blue",
bg: "bg-neon-blue/10"
},
{
name: "ูุฑูุณ (H)",
role: "ุขุดูุจ",
desc: "ุฎุงูู ุฑุง ุจู ุญุงูุช ูุงูพุงุฏุงุฑ (FLUX) ูโุจุฑุฏ. ุขุดูุจ ุฑุง ุจู ุชูุงู ธ ููุณุงู ุงุทุฑุงู ูพุฎุด ูโฺฉูุฏ.",
note: "ุฑุณฺฉ ุจุงูุงุ ูพุงุฏุงุด ุจุงูุง.",
color: "text-neon-pink",
border: "border-neon-pink",
bg: "bg-neon-pink/10"
}
]
},
{
id: "entropy",
title: "ุขูุชุฑููพ ุณุณุชู",
color: "#aa00ff",
body: "ูุฑ ุญุฑฺฉุช ุจุงุนุซ ุงูุฒุงุด ูุงูพุงุฏุงุฑ ุณุณุชู ูโุดูุฏ. ููุช ุดุจฺฉู ูพุฑ ุดูุฏุ ูุณุชู ูุฑู ูโุฑุฒุฏ. ุชูุงู ุฎุงููโูุง ยซูุฑูุณยป (ูุงูพุงุฏุงุฑ) ููุฑุงู ุจุฑ ุงุณุงุณ ุงุญุชูุงูุงุชุ ุง ุจู ููุน ุดูุง ู ุง ููุด ูุตููุน ุชุซุจุช ูโุดููุฏ."
},
{
id: "outcomes",
title: "ูุชุงุฌ ููุง",
color: "gray",
body: "ูพุณ ุงุฒ ูพุงุงู ุนููุงุชุ ุงูุชุงุฒ ููุง ูุญุงุณุจู ูโุดูุฏ:",
states: [
{ label: "ูพุฑูุฒ", text: "ุณุณุชู ุจุงุฒููุณ ุดุฏ. ุฏุณุชุฑุณ ูุฌุงุฒ ุงุณุช.", color: "text-neon-blue" },
{ label: "ุดฺฉุณูุช", text: "ูููุฐ ุดูุงุณุง ุดุฏ. ูพููุฏ ุนุตุจ ูุทุน ฺฏุฑุฏุฏ.", color: "text-neon-pink" },
{ label: "ุชุณุงู", text: "โ ุฎุทุง ุจุญุฑุงู. ุฐูุจ ูุณุชู ูุฑุจโุงููููุน ุงุณุช. ููุฑุงู ุชุฎูู ฺฉูุฏ.", color: "text-yellow-400" }
]
}
],
back: "ุขุบุงุฒ ุนููุงุช"
}
};

const GameGuide = () => {
  const [lang, setLang] = useState<Lang>('en');

  // Removed local background & visibility logic (Handled by App.tsx)

  return (
    // Height fixed to viewport, no background logic needed here
    <div className="relative w-full h-[100dvh] flex flex-col items-center overflow-hidden">
      
      {/* 2. GLASS HEADER */}
      <div className="z-20 w-full p-4 md:p-6 flex justify-between items-center border-b border-white/10 bg-black/20 backdrop-blur-md shrink-0">
        <div>
          <h1 className="text-2xl md:text-3xl font-black tracking-tighter text-white drop-shadow-[0_0_10px_rgba(255,255,255,0.5)]">
            {CONTENT[lang].title}
          </h1>
          <div className="flex items-center gap-2 mt-1">
            <span className="w-2 h-2 bg-neon-green rounded-full animate-pulse"></span>
            <p className="text-[10px] md:text-xs text-neon-blue tracking-[0.2em]">
              {CONTENT[lang].subtitle}
            </p>
          </div>
        </div>

        {/* TERMINAL TOGGLE */}
        <div className="flex bg-black/40 rounded border border-gray-700">
          <button 
            onClick={() => setLang('en')}
            className={clsx("px-3 py-1 text-xs font-bold transition-all", lang === 'en' ? "bg-neon-blue text-black" : "text-gray-500 hover:text-white")}
          >
            EN
          </button>
          <div className="w-px bg-gray-700"></div>
          <button 
            onClick={() => setLang('fa')}
            className={clsx("px-3 py-1 text-xs font-bold transition-all font-sans", lang === 'fa' ? "bg-neon-blue text-black" : "text-gray-500 hover:text-white")}
          >
            FA
          </button>
        </div>
      </div>

      {/* 3. SCROLLABLE CONTENT AREA */}
      <div className="z-10 w-full max-w-4xl flex-1 overflow-y-auto custom-scrollbar p-4 md:p-8 pb-32 touch-pan-y">
        <AnimatePresence mode='wait'>
          <motion.div
            key={lang}
            initial={{ opacity: 0, x: -10 }}
            animate={{ opacity: 1, x: 0 }}
            exit={{ opacity: 0, x: 10 }}
            transition={{ duration: 0.2 }}
            dir={lang === 'fa' ? 'rtl' : 'ltr'}
            className={clsx("space-y-8", lang === 'fa' ? 'font-sans' : 'font-mono')}
          >
            
            {CONTENT[lang].sections.map((section) => (
              <div key={section.id} className="relative group">
                {/* Decorative Brackets (Theme Consistency) */}
                <div className="absolute -left-2 -top-2 w-4 h-4 border-l-2 border-t-2 border-gray-700 group-hover:border-neon-blue transition-colors"></div>
                <div className="absolute -right-2 -top-2 w-4 h-4 border-r-2 border-t-2 border-gray-700 group-hover:border-neon-blue transition-colors"></div>

                {/* Glass Panel */}
                <div className="bg-black/30 border border-white/10 backdrop-blur-sm p-6 md:p-8 rounded-sm hover:border-white/20 transition-all">
                    
                    {/* Header */}
                    <h2 className={`text-xl font-black mb-4 tracking-widest ${section.color}`}>
                        {section.title}
                    </h2>

                    {/* Body */}
                    <p className="text-sm md:text-base leading-relaxed text-gray-300 whitespace-pre-line border-l-2 border-gray-800 pl-4">
                        {section.body}
                    </p>

                    {/* Footer Data */}
                    {section.footer && (
                      <div className="mt-4 pt-4 border-t border-gray-800 text-xs font-bold text-gray-500">
                        {`>> ${section.footer}`}
                      </div>
                    )}

                    {/* ARSENAL CARDS (Holographic Look) */}
                    {section.cards && (
                      <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mt-6">
                        {section.cards.map((card, i) => (
                          <div key={i} className={`relative border ${card.border} ${card.bg} p-4 transition-all hover:scale-[1.02] hover:shadow-[0_0_15px_rgba(0,0,0,0.5)] rounded-lg backdrop-blur-md`}>
                             {/* Card Scanline */}
                             <div className="absolute inset-0 bg-gradient-to-b from-transparent via-white/5 to-transparent opacity-0 hover:opacity-100 pointer-events-none transition-opacity"></div>
                             
                             <div className={`text-[10px] font-black tracking-widest mb-1 ${card.color}`}>{card.role}</div>
                             <div className="text-base font-bold text-white mb-2">{card.name}</div>
                             <div className="text-xs text-gray-300 leading-snug mb-3 opacity-80">{card.desc}</div>
                             <div className="text-[9px] text-white/50 border-t border-white/10 pt-2 font-bold">
                               {`// ${card.note}`}
                             </div>
                          </div>
                        ))}
                      </div>
                    )}

                    {/* OUTCOMES LIST */}
                    {section.states && (
                      <div className="grid grid-cols-1 gap-2 mt-4">
                        {section.states.map((state, i) => (
                           <div key={i} className={`flex items-center gap-4 p-3 bg-black/40 border-l-4 ${state.color}`}>
                              <span className={`font-black text-xs min-w-[60px]`}>{state.label}</span>
                              <span className="text-xs text-gray-400 font-bold">{state.text}</span>
                           </div>
                        ))}
                      </div>
                    )}
                </div>
              </div>
            ))}

          </motion.div>
        </AnimatePresence>
      </div>

      {/* 4. FOOTER */}
      <div className="fixed bottom-0 w-full p-6 bg-gradient-to-t from-black via-black/90 to-transparent z-30 flex justify-center shrink-0">
        <Link to="/">
          <button className="group relative px-12 py-4 bg-black/40 border border-neon-blue/50 text-neon-blue font-black tracking-[0.2em] hover:bg-neon-blue hover:text-black transition-all text-xs md:text-sm overflow-hidden backdrop-blur-md">
            <span className="relative z-10">{CONTENT[lang].back}</span>
            <div className="absolute inset-0 bg-neon-blue translate-y-full group-hover:translate-y-0 transition-transform duration-300 z-0"></div>
          </button>
        </Link>
      </div>

    </div>
  );
};

export default GameGuide;
--- END OF FILE: src\pages\GameGuide.tsx ---


--- START OF FILE: src\pages\GameSession.tsx ---
// src/pages/GameSession.tsx
import { Canvas } from '@react-three/fiber';
import { XR, createXRStore } from '@react-three/xr';
import { OrbitControls } from '@react-three/drei';
import { useGameStore, useStatus, useInstability } from '../store/gameStore';
import { useMemo, useState, useRef, Suspense, useEffect } from 'react';
import { Navigate, useNavigate } from 'react-router-dom';

// Engine
import { GeometryManager } from '../engine/core/GeometryManager';

// Components
import { QuantumBoard } from '../components/canvas/board/QuantumBoard';
import BackgroundScene from '../components/canvas/BackgroundScene';
import { GameHUD } from '../components/dom/hud/GameHUD';
import { VFXManager } from '../components/canvas/effects/VFXManager';
import { ARPlacement } from '../components/canvas/ar/ARPlacement'; 

const store = createXRStore({
  hitTest: true,
  foveation: 0,
});

const GameSession = () => {
  const navigate = useNavigate();
  
  const status = useStatus();
  const instability = useInstability();
  
  const isARMode = useGameStore(s => s.isARMode);
  const opponentDisconnected = useGameStore(s => s.opponentDisconnected);
  const exitGame = useGameStore(s => s.exitGame);
  const isLoading = useGameStore(s => s.isLoading);

  const [arStarted, setArStarted] = useState(false);
  const [arError, setArError] = useState<string | null>(null);
  const uiRef = useRef<HTMLDivElement>(null);

  const backgroundSpeed = useMemo(() => {
    return 1 + (instability / 100) * 4;
  }, [instability]);

  // OPTIMIZATION: Resource Cleanup on Unmount
  useEffect(() => {
    return () => {
      // 1. Dispose Geometry Cache
      GeometryManager.dispose();

      // 2. Clean up XR session
      // @ts-ignore
      if (store.session) {
          // @ts-ignore
          store.session.end().catch((err) => console.warn("Session end warning:", err));
      }
    };
  }, []);

  // PREVENT REDIRECT IF LOADING
  if (status === 'idle' && !isLoading) {
    return <Navigate to="/" replace />;
  }

  const handleExit = () => {
    exitGame();
    navigate('/');
  };

  const handleStartAR = async () => {
    setArError(null);
    if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost') {
      setArError("AR REQUIRES HTTPS.");
      return;
    }
    if (!('xr' in navigator)) {
      setArError("WEBXR NOT FOUND.");
      return;
    }

    if (uiRef.current) {
      try {
        const sessionOptions = {
          requiredFeatures: ['local-floor'],
          optionalFeatures: ['hit-test', 'dom-overlay'],
          domOverlay: { root: uiRef.current }
        };
        // @ts-ignore
        await store.enterAR(sessionOptions);
        setArStarted(true);
      } catch (e: any) {
        // Fallback
        try {
            // @ts-ignore
            await store.enterAR({ requiredFeatures: ['local-floor'], optionalFeatures: ['hit-test'] });
            setArStarted(true);
        } catch (retryError: any) {
            setArError(`AR FAILED: ${retryError.message}`);
        }
      }
    }
  };

  if (status === 'waiting_for_opponent') {
    return (
      <div className="w-full h-full bg-black flex flex-col items-center justify-center relative overflow-hidden">
        {/* Waiting Room still needs its own background since Game Canvas isn't mounted yet */}
        <div className="absolute inset-0 z-0">
           <Canvas camera={{ position: [0, 0, 30], fov: 60 }} resize={{ scroll: false }}>
             <BackgroundScene speed={0.5} autoShift={true} />
           </Canvas>
        </div>
        
        <div className="z-10 p-8 border border-neon-blue/30 bg-gray-900/80 backdrop-blur-md rounded-2xl text-center shadow-[0_0_50px_rgba(0,243,255,0.1)]">
          <div className="w-16 h-16 border-4 border-t-neon-blue border-r-transparent border-b-neon-blue border-l-transparent rounded-full animate-spin mx-auto mb-6"></div>
          <h2 className="text-2xl font-black text-white mb-2 tracking-widest">ESTABLISHING UPLINK</h2>
          <div className="mt-8">
            <button onClick={handleExit} className="text-xs text-gray-500 hover:text-white underline decoration-dotted underline-offset-4">
              ABORT CONNECTION
            </button>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="relative w-full h-full bg-black transition-colors duration-1000">
      
      {/* --- UI OVERLAY LAYER --- */}
      <div 
        ref={uiRef} 
        id="xr-overlay"
        style={{ 
          position: 'absolute', 
          top: 0, left: 0, width: '100%', height: '100%',
          zIndex: 10000, 
          pointerEvents: 'none', 
          background: 'transparent',
          display: 'flex', flexDirection: 'column'
        }}
      >
        <GameHUD />

        {opponentDisconnected && (
          <div className="absolute inset-0 bg-black/90 flex flex-col items-center justify-center pointer-events-auto z-[200]">
            <div className="bg-gray-900 border-2 border-neon-pink p-8 rounded-xl text-center shadow-[0_0_50px_#ff0055] max-w-sm mx-4">
              <h2 className="text-2xl text-neon-pink font-black mb-2 tracking-tighter">SIGNAL LOST</h2>
              <button onClick={handleExit} className="px-6 py-3 bg-white text-black font-bold tracking-widest rounded hover:bg-gray-200 transition-colors">
                RETURN TO BASE
              </button>
            </div>
          </div>
        )}
        
        {isARMode && !arStarted && !opponentDisconnected && (
          <div className="absolute inset-0 flex flex-col items-center justify-center bg-black/90 pointer-events-auto p-4">
             {arError && (
               <div className="mb-6 p-4 bg-red-900/50 border border-red-500 text-white text-center rounded max-w-md">
                 <div className="font-bold mb-1">SYSTEM ERROR</div>
                 <div className="text-xs font-mono">{arError}</div>
               </div>
             )}
             <button 
              onClick={handleStartAR}
              className="px-8 py-4 bg-neon-green/20 border-2 border-neon-green text-neon-green font-black tracking-[0.2em] hover:bg-neon-green hover:text-black transition-all shadow-[0_0_30px_#00ff41] uppercase"
            >
              INITIALIZE AR UPLINK
            </button>
          </div>
        )}
      </div>

      {/* --- 3D SCENE LAYER --- */}
      {/* 
         CRITICAL OPTIMIZATION #2: 
         Single Canvas for everything (Game + Background) 
      */}
      <Canvas 
        className="z-10"
        dpr={[1, 1.5]} 
        gl={{ 
          powerPreference: "high-performance",
          antialias: !isARMode, // Disable AA in AR for performance
          stencil: true,
          depth: true,
          alpha: isARMode // Transparent canvas only needed for AR passthrough
        }} 
        style={{ position: 'absolute', top: 0, left: 0, zIndex: 1 }}
      >
        {isARMode ? (
           <XR store={store}>
             <Suspense fallback={null}>
               <VFXManager />
               <ARPlacement>
                 <QuantumBoard />
               </ARPlacement>
             </Suspense>
           </XR>
        ) : (
           <>
             {/* Background is now INSIDE the game canvas */}
             <BackgroundScene speed={backgroundSpeed} autoShift={false} />
             
             <OrbitControls 
               makeDefault
               minPolarAngle={0} 
               maxPolarAngle={Math.PI / 2.2}
               maxDistance={25}
               minDistance={5}
               enablePan={true}
             />
             
             <Suspense fallback={null}>
               <VFXManager />
               <QuantumBoard />
             </Suspense>
           </>
        )}
      </Canvas>

    </div>
  );
};

export default GameSession;
--- END OF FILE: src\pages\GameSession.tsx ---


--- START OF FILE: src\pages\Home.tsx ---
// src/pages/Home.tsx
import { useEffect, useRef, useCallback } from 'react';
import { motion } from 'framer-motion';
import { Link } from 'react-router-dom';
import { Logo } from '../components/dom/ui/logo';

const Home = () => {
  const soloBtnRef = useRef<HTMLAnchorElement>(null);
  const lobbyBtnRef = useRef<HTMLAnchorElement>(null);

  // OPTIMIZATION #5: Intelligent Preloading
  // Instead of loading everything at once, we load when user shows intent (hovers/sees buttons)
  const preloadCritical = useCallback(() => {
    import('./GameSession'); 
    import('../components/canvas/board/QuantumBoard');
    import('../engine/core/QuantumLogic');
  }, []);

  const preloadLobby = useCallback(() => import('./Lobby'), []);
  const preloadDocs = useCallback(() => { import('./GameGuide'); import('./MinimaxInfo'); }, []);

  useEffect(() => {
    // Observer to preload game when buttons are visible on screen
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          preloadCritical();
          observer.disconnect(); // Only need to trigger once
        }
      });
    }, { threshold: 0.5 });

    if (soloBtnRef.current) observer.observe(soloBtnRef.current);

    return () => observer.disconnect();
  }, [preloadCritical]);

  // --- LIQUID GLASS BUTTON ---
  const LiquidButton = ({ to, label, icon, colorClass, borderClass, onHover, refProp }: any) => (
    <Link to={to} ref={refProp} className="w-full group/btn relative">
      <button 
        onMouseEnter={onHover}
        onTouchStart={onHover}
        className={`
          relative w-full py-5 px-6 rounded-lg overflow-hidden transition-all duration-300
          bg-black/10 hover:bg-black/30 
          backdrop-blur-md 
          border ${borderClass}
          shadow-[0_0_15px_rgba(0,0,0,0.1)] hover:shadow-[0_0_20px_rgba(0,0,0,0.4)]
        `}
      >
        <div className="flex items-center justify-between relative z-10">
          <div className="flex items-center gap-4">
            <span className={`text-2xl filter drop-shadow-sm ${colorClass} opacity-80 group-hover/btn:opacity-100 transition-opacity`}>
              {icon}
            </span>
            <span className={`font-black tracking-[0.2em] text-sm md:text-base ${colorClass} drop-shadow-md`}>
              {label}
            </span>
          </div>
          
          {/* Tech Arrow */}
          <div className={`opacity-0 -translate-x-2 group-hover/btn:opacity-100 group-hover/btn:translate-x-0 transition-all duration-300 ${colorClass}`}>
            ยป
          </div>
        </div>
      </button>
    </Link>
  );

  return (
    <div className="relative w-full h-[100dvh] flex flex-col items-center justify-center overflow-hidden">
      
      {/* MAIN CONTAINER */}
      <motion.div 
        initial={{ opacity: 0, scale: 0.95 }}
        animate={{ opacity: 1, scale: 1 }}
        transition={{ duration: 0.8, ease: "circOut" }}
        className="z-10 w-full max-w-sm px-6 flex flex-col gap-10 relative"
      >
        
        {/* --- DECORATIVE BRACKETS --- */}
        <div className="absolute -left-2 -top-6 w-8 h-8 border-l-2 border-t-2 border-white/10"></div>
        <div className="absolute -right-2 -bottom-6 w-8 h-8 border-r-2 border-b-2 border-white/10"></div>

        {/* LOGO */}
        <Logo scale={1.0} />

        {/* --- MAIN BUTTONS --- */}
        <div className="flex flex-col gap-4">
          
          {/* SINGLE PLAYER */}
          <LiquidButton 
            refProp={soloBtnRef}
            to="/setup" 
            label="SINGLE PLAYER" 
            icon="โก"
            colorClass="text-cyan-400 group-hover/btn:text-cyan-200"
            borderClass="border-cyan-500/30 group-hover/btn:border-cyan-400/80"
            onHover={preloadCritical} 
          />

          {/* MULTIPLAYER */}
          <LiquidButton 
            refProp={lobbyBtnRef}
            to="/lobby" 
            label="MULTIPLAYER" 
            icon="๐"
            colorClass="text-fuchsia-400 group-hover/btn:text-fuchsia-200"
            borderClass="border-fuchsia-500/30 group-hover/btn:border-fuchsia-400/80"
            onHover={preloadLobby} 
          />

        </div>

        {/* --- SECONDARY LINKS --- */}
        <div className="grid grid-cols-2 gap-3">
          <Link to="/guide" onMouseEnter={preloadDocs} className="group/small">
            <div className="h-full py-3 rounded bg-black/10 border border-white/10 hover:border-white/30 backdrop-blur-sm transition-all text-center">
              <span className="text-[10px] font-bold tracking-widest text-gray-500 group-hover/small:text-white transition-colors">MANUAL</span>
            </div>
          </Link>
          
          <Link to="/ai-logic" onMouseEnter={preloadDocs} className="group/small">
            <div className="h-full py-3 rounded bg-black/10 border border-white/10 hover:border-white/30 backdrop-blur-sm transition-all text-center">
              <span className="text-[10px] font-bold tracking-widest text-gray-500 group-hover/small:text-white transition-colors">AI_CORE</span>
            </div>
          </Link>
        </div>

      </motion.div>

      {/* FOOTER */}
      <a 
        href="https://github.com/Amkhodaei83" 
        target="_blank" 
        rel="noopener noreferrer"
        className="absolute bottom-6 z-20 group cursor-pointer"
      >
        <div className="flex items-center gap-2 px-4 py-2 rounded-full bg-black/20 border border-white/5 hover:border-white/20 backdrop-blur-sm transition-all hover:scale-105">
          <span className="text-[9px] text-gray-500 tracking-widest group-hover:text-gray-400 transition-colors">
            CODED_BY //
          </span>
          <span className="text-[10px] font-black text-white tracking-widest group-hover:text-cyan-400 transition-colors">
            AMIR HOSSEIN KHODAEI
          </span>
        </div>
      </a>

    </div>
  );
};

export default Home;
--- END OF FILE: src\pages\Home.tsx ---


--- START OF FILE: src\pages\Lobby.tsx ---
// src/pages/Lobby.tsx
import { useEffect, useState, useCallback, useRef, memo } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import { useGameStore } from '../store/gameStore';
import { clsx } from 'clsx';

interface Room {
  id: string;
  players: number;
}

// OPTIMIZATION: Memoized Row Component
// This prevents the entire list from re-rendering when you type in the input box
const RoomItem = memo(({ room, onClick }: { room: Room; onClick: (id: string) => void }) => {
  return (
    <div
      onClick={() => onClick(room.id)}
      className="group cursor-pointer bg-black/40 border border-white/5 hover:border-fuchsia-500 hover:bg-fuchsia-900/10 p-4 rounded flex justify-between items-center transition-all mb-3"
    >
      <div className="flex items-center gap-3">
        <div className="w-1.5 h-1.5 bg-fuchsia-500 rounded-full group-hover:shadow-[0_0_8px_#d946ef]"></div>
        <div className="font-bold text-white text-sm tracking-wide group-hover:text-fuchsia-400 transition-colors">
          {room.id}
        </div>
      </div>
      <div className="flex items-center gap-2">
        <span className="text-[10px] font-bold text-gray-500 group-hover:text-fuchsia-300">
          WAITING
        </span>
        <span className="text-lg opacity-50 group-hover:opacity-100 group-hover:translate-x-1 transition-all">
          ยป
        </span>
      </div>
    </div>
  );
});

const Lobby = () => {
  const navigate = useNavigate();
  const joinMultiplayerRoom = useGameStore(state => state.joinMultiplayerRoom);
  const setARMode = useGameStore(state => state.setARMode);
  
  const [rooms, setRooms] = useState<Room[]>([]);
  const [newRoomName, setNewRoomName] = useState('');
  const [isAR, setIsAR] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const isPageVisible = useRef(true);

  // --- BATTERY SAVER POLLING ---
  useEffect(() => {
    const handleVisibilityChange = () => { isPageVisible.current = document.visibilityState === 'visible'; };
    document.addEventListener("visibilitychange", handleVisibilityChange);
    return () => document.removeEventListener("visibilitychange", handleVisibilityChange);
  }, []);

  const fetchRooms = useCallback(async () => {
    if (!isPageVisible.current) return;
    try {
      const res = await fetch('/api/rooms', { headers: { 'Accept': 'application/json' }, priority: 'low' } as any);
      if (res.ok) {
        const data = await res.json();
        // Only update if data actually changed to avoid list flicker
        setRooms(prev => JSON.stringify(prev) !== JSON.stringify(data) ? data : prev);
      }
    } catch (err) { console.warn("Lobby Poll Failed"); }
  }, []);

  useEffect(() => {
    fetchRooms();
    const interval = setInterval(fetchRooms, 4000);
    return () => clearInterval(interval);
  }, [fetchRooms]);

  // --- ACTIONS ---
  const validateAndJoin = useCallback((roomId: string) => {
    // OPTIMIZATION: Client-side Sanitization
    const cleanId = roomId.trim().toUpperCase().replace(/[^A-Z0-9-]/g, '');
    if (cleanId.length < 3) { setError("ID TOO SHORT"); return; }
    if (cleanId.length > 12) { setError("ID TOO LONG"); return; }
    
    // We access the *current* state of isAR via the store setter if needed, 
    // but here we use the local state before dispatching.
    setARMode(isAR);
    joinMultiplayerRoom(cleanId);
    navigate('/game');
  }, [isAR, joinMultiplayerRoom, navigate, setARMode]);

  const handleCreate = () => {
    if (!newRoomName) {
      const randomId = `SEC-${Math.floor(Math.random()*9000) + 1000}`;
      validateAndJoin(randomId);
    } else {
      validateAndJoin(newRoomName);
    }
  };

  return (
    <div className="relative w-full h-[100dvh] text-white font-mono flex flex-col items-center overflow-hidden">
      
      {/* 1. HEADER */}
      <div className="z-20 w-full p-4 md:p-6 flex justify-between items-center border-b border-white/10 bg-black/20 backdrop-blur-md shrink-0">
        <div>
          <h1 className="text-2xl md:text-3xl font-black tracking-tighter text-white drop-shadow-[0_0_10px_rgba(255,255,255,0.5)]">
            NET_LOBBY
          </h1>
          <div className="flex items-center gap-2 mt-1">
            <span className="w-2 h-2 bg-neon-pink rounded-full animate-pulse"></span>
            <p className="text-[10px] md:text-xs text-fuchsia-400 tracking-[0.2em]">
              SEARCHING FOR SIGNALS...
            </p>
          </div>
        </div>

        <Link to="/">
          <button className="px-4 py-2 text-xs font-bold text-gray-400 hover:text-white border border-transparent hover:border-gray-600 rounded transition-all bg-black/40">
            &lt; DISCONNECT
          </button>
        </Link>
      </div>

      {/* 2. MAIN CONTENT AREA */}
      <div className="z-10 w-full max-w-md flex-1 flex flex-col gap-6 p-6 overflow-hidden">
        
        {/* --- SECTION A: COMMAND CENTER --- */}
        <div className="relative group shrink-0">
            <div className="absolute -left-2 -top-2 w-4 h-4 border-l-2 border-t-2 border-fuchsia-500/50"></div>
            <div className="absolute -right-2 -bottom-2 w-4 h-4 border-r-2 border-b-2 border-fuchsia-500/50"></div>

            <div className="bg-black/40 border border-white/10 backdrop-blur-md p-6 rounded-lg flex flex-col gap-4 shadow-lg">
                
                {/* Input */}
                <div>
                    <label className="text-[10px] font-bold text-fuchsia-400 tracking-widest mb-2 block">
                        TARGET FREQUENCY (ROOM ID)
                    </label>
                    <div className="relative">
                        <input 
                            type="text" 
                            placeholder="AUTO-GENERATE" 
                            value={newRoomName}
                            onChange={(e) => { setError(null); setNewRoomName(e.target.value.toUpperCase()); }}
                            maxLength={12}
                            className="w-full bg-black/50 border border-white/20 p-4 text-white placeholder-gray-600 focus:border-fuchsia-500 outline-none rounded font-bold tracking-widest transition-colors uppercase"
                        />
                        <div className="absolute right-4 top-1/2 -translate-y-1/2 w-2 h-4 bg-fuchsia-500 animate-pulse"></div>
                    </div>
                    {error && (
                        <div className="text-[10px] text-red-500 font-bold mt-2 animate-pulse">
                            โ ERROR: {error}
                        </div>
                    )}
                </div>

                {/* AR Toggle */}
                <div 
                    onClick={() => setIsAR(!isAR)}
                    className={clsx(
                        "cursor-pointer p-3 rounded border transition-all duration-300 flex items-center justify-between group/ar",
                        isAR ? "bg-neon-green/10 border-neon-green" : "bg-black/30 border-gray-700 hover:border-gray-500"
                    )}
                >
                    <div className="flex flex-col">
                        <span className={clsx("text-xs font-black tracking-widest transition-colors", isAR ? "text-neon-green" : "text-gray-400")}>
                            AR_PASSTHROUGH
                        </span>
                        <span className="text-[9px] text-gray-500">
                            {isAR ? "CAMERA FEED ACTIVE" : "STANDARD 3D VIEW"}
                        </span>
                    </div>
                    
                    <div className={clsx("w-10 h-5 rounded-full relative transition-colors", isAR ? "bg-neon-green" : "bg-gray-800")}>
                        <div className={clsx("absolute top-1 w-3 h-3 bg-black rounded-full shadow-md transition-transform duration-300", isAR ? "left-6" : "left-1")}></div>
                    </div>
                </div>

                {/* Join Button */}
                <button 
                    onClick={handleCreate}
                    className="w-full py-4 bg-fuchsia-600/20 border border-fuchsia-500 text-fuchsia-400 font-black tracking-[0.2em] hover:bg-fuchsia-500 hover:text-black transition-all rounded shadow-[0_0_15px_rgba(217,70,239,0.2)] hover:shadow-[0_0_25px_rgba(217,70,239,0.5)] active:scale-[0.98]"
                >
                    ESTABLISH UPLINK
                </button>
            </div>
        </div>

        {/* --- SECTION B: SIGNAL FEED (Standard List) --- */}
        <div className="flex-1 flex flex-col min-h-0">
            <div className="flex items-center gap-2 mb-4 opacity-50 shrink-0">
                <div className="h-px flex-1 bg-gray-700"></div>
                <span className="text-[10px] font-bold text-gray-500 tracking-widest">ACTIVE SIGNALS</span>
                <div className="h-px flex-1 bg-gray-700"></div>
            </div>

            <div className="flex-1 overflow-y-auto custom-scrollbar">
                {rooms.length === 0 ? (
                    <div className="text-center py-12 border border-dashed border-gray-800 rounded bg-black/20">
                        <div className="text-2xl mb-2 opacity-30">๐ก</div>
                        <div className="text-xs text-gray-500 font-bold tracking-widest animate-pulse">SCANNING SECTOR...</div>
                        <div className="text-[10px] text-gray-700 mt-1">NO ACTIVE BEACONS FOUND</div>
                    </div>
                ) : (
                    rooms.map((room) => (
                        <RoomItem key={room.id} room={room} onClick={validateAndJoin} />
                    ))
                )}
            </div>
        </div>

      </div>
    </div>
  );
};

export default Lobby;
--- END OF FILE: src\pages\Lobby.tsx ---


--- START OF FILE: src\pages\MinimaxInfo.tsx ---
// src/pages/MinimaxInfo.tsx
import { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Link } from 'react-router-dom';
import { clsx } from 'clsx';

// --- TYPES ---

type Lang = 'en' | 'fa';

// Discriminated Union for different content block types
type BlockType = 'paragraph' | 'code' | 'list' | 'formula' | 'card';

interface BaseBlock {
  type: BlockType;
}

interface ParagraphBlock extends BaseBlock {
  type: 'paragraph';
  text: string;
}

interface CodeBlock extends BaseBlock {
  type: 'code';
  language?: string; // e.g., "PYTHON", "PSEUDOCODE"
  code: string;
}

interface ListBlock extends BaseBlock {
  type: 'list';
  items: string[];
}

interface FormulaBlock extends BaseBlock {
  type: 'formula';
  math: string;
}

interface CardBlock extends BaseBlock {
  type: 'card';
  title: string;
  content: string | string[]; // Can be a simple string or a list of items
}

type ContentBlock = ParagraphBlock | CodeBlock | ListBlock | FormulaBlock | CardBlock;

interface Section {
  id: string;
  title: string;
  color: string;
  blocks: ContentBlock[]; // Changed from simple 'body' string to array of blocks
  footer?: string;
}

interface PageContent {
  title: string;
  subtitle: string;
  sections: Section[];
  back: string;
}

// --- DATA STRUCTURE (EMPTY) ---

const CONTENT: Record<Lang, PageContent> = {
  en: {
    title: "NEURAL_CORE",
    subtitle: "ALGORITHMIC_ANALYSIS_V4.0",
    sections: [
  {
    id: "intro",
    title: "01 // INTRODUCTION & PROJECT OVERVIEW",
    color: "text-blue-400",
    blocks: [
      {
        type: "paragraph",
        text: "Project Quantum Breach is a turn-based strategy game inspired by quantum computing and cybersecurity concepts. Running on the web platform, it aims to deliver a high-end graphical experience using modern web technologies."
      },
      {
        type: "card",
        title: "TECH STACK",
        content: [
          "Frontend Framework: React 19 (UI & State)",
          "3D Engine: Three.js + React Three Fiber",
          "State Management: Zustand",
          "Build Tool: Vite",
          "Styling: Tailwind CSS",
          "Language: TypeScript",
          "XR/AR: WebXR + React Three XR",
          "Backend: Node.js + Express + Socket.io"
        ]
      },
      {
        type: "paragraph",
        text: "The core game operates on a 6x6 grid where players (Hacker vs AI/Security) use three types of logic gates (Firewall, Injector, Virus) to control Qubits. The main technical challenge was implementing a powerful browser-based AI without blocking the main thread, alongside a lag-free multiplayer experience using deterministic synchronization."
      }
    ]
  },
  {
    id: "ai-minimax",
    title: "02 // NEURAL CORE: MINIMAX & SEARCH ANALYSIS",
    color: "text-green-400",
    blocks: [
      {
        type: "paragraph",
        text: "The game's mastermind is a custom AI engine built on the Minimax algorithm with Alpha-Beta Pruning. Unlike many web games using simple 'if-else' logic, this AI simulates the game tree to a specific depth (4-6 layers depending on difficulty)."
      },
      {
        type: "paragraph",
        text: "To distinguish between 'good' and 'bad' states, it employs a deterministic Utility Function. This function assigns a numerical score U(s) to every board state:"
      },
      {
        type: "formula",
        math: "U(s) = (W_m ยท M(s)) + (W_p ยท P(s)) + (W_c ยท C(s)) - (W_t ยท T(s))"
      },
      {
        type: "list",
        items: [
          "M(s) (Material): Net piece value. Locked gates are worth 3x more than Stable gates due to invulnerability.",
          "P(s) (Positional): Strategic value based on Heatmap. Center nodes allow access to more neighbors.",
          "C(s) (Clustering): Bonus for creating chains of connected friendly nodes.",
          "T(s) (Threats): Penalty if pieces are under immediate attack."
        ]
      },
      {
        type: "card",
        title: "HEATMAP IMPLEMENTATION",
        content: "The array below (from minimax.worker.ts) defines the intrinsic value of every cell. Higher numbers (12) indicate the strategic center, while lower numbers (2) indicate corners."
      },
      {
        type: "code",
        language: "TYPESCRIPT",
        code: "const POSITION_VALUES = new Int8Array([\n  2,  3,  4,  4,  3,  2,\n  3,  6,  8,  8,  6,  3,\n  4,  8, 12, 12,  8,  4,\n  4,  8, 12, 12,  8,  4,\n  3,  6,  8,  8,  6,  3,\n  2,  3,  4,  4,  3,  2\n]);"
      },
      {
        type: "paragraph",
        text: "A major challenge in Quantum Breach is the Injector (X) gate, which has a 50% failure rate on diagonals. Traditional Minimax fails in non-deterministic environments. We solved this using Expected Utility Theory. When evaluating a move involving chance, the branch splits into two outcomes:"
      },
      {
        type: "formula",
        math: "EU(action) = ฮฃ P(outcome_i) ร U(outcome_i)"
      },
      {
        type: "formula",
        math: "EU = (0.5 ร U_success) + (0.5 ร U_fail)"
      },
      {
        type: "paragraph",
        text: "The AI also 'understands' Entropy. In a Winning State, it minimizes variance using Firewalls to lock the board. In a Losing State, it maximizes variance using Viruses to turn Stable enemy nodes into volatile Flux nodes, turning a certain loss into a 50/50 gamble."
      },
      {
        type: "paragraph",
        text: "To achieve 60 FPS while calculating, the architecture uses specific optimizations:"
      },
      {
        type: "list",
        items: [
          "Dedicated Web Worker: All logic runs off the main thread.",
          "TypedArrays: Using Int8Array instead of standard arrays for memory efficiency.",
          "Neighbors Cache: Pre-computed flat array for instant spatial lookups."
        ]
      },
      {
        type: "card",
        title: "PERFORMANCE: TRANSFERABLE OBJECTS",
        content: "We use Transferable Objects to pass memory buffers to the Worker. This means data is moved rather than copied, reducing communication overhead to near zero."
      }
    ]
  },
  {
    id: "multiplayer",
    title: "03 // NETWORK ARCHITECTURE: DETERMINISTIC SYNC",
    color: "text-purple-400",
    blocks: [
      {
        type: "paragraph",
        text: "Multiplayer is implemented via WebSockets (Socket.io). The Node.js server manages matchmaking and rooms, but physical logic is client-side."
      },
      {
        type: "paragraph",
        text: "To sync state without sending the massive board object every frame, we use Input Streaming. Since the game logic is deterministic, if both clients start with the same state and receive the same inputs (plus the same random numbers), the result is identical."
      },
      {
        type: "card",
        title: "RNG SYNCHRONIZATION VIA SEEDS",
        content: "If Player A generates a random number for an attack and wins, Player B must generate the exact same number. To ensure this, the acting client sends a 'seed' with their move. Both clients use a custom PRNG (Mulberry32) seeded with this value."
      },
      {
        type: "code",
        language: "TYPESCRIPT",
        code: "// QuantumLogic.ts\nexport const mulberry32 = (a: number) => {\n  return () => {\n    let t = a += 0x6D2B79F5;\n    t = Math.imul(t ^ (t >>> 15), t | 1);\n    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;\n  }\n};"
      },
      {
        type: "paragraph",
        text: "Network payloads are minimal to optimize bandwidth:"
      },
      {
        type: "code",
        language: "TYPESCRIPT",
        code: "interface MovePayload {\n  roomId: string;\n  nodeId: number;\n  gate: 'Z' | 'X' | 'H';\n  seed: number;\n}"
      },
      {
        type: "paragraph",
        text: "Although calculation is client-side, the server acts as the Authoritative Source for validation:"
      },
      {
        type: "list",
        items: [
          "Turn Validation: Ensures it is actually the requester's turn.",
          "Rule Validation: Checks if the target cell is empty and gate type is valid.",
          "Rate Limiting: Prevents DoS/Spam attacks."
        ]
      },
      {
        type: "paragraph",
        text: "The system handles disconnections robustly: The server broadcasts 'player_left', the opponent enters a waiting state, and the disconnected client attempts auto-reconnection (up to 5 attempts) before the match is terminated."
      }
    ]
  },
  {
    id: "ar-webxr",
    title: "04 // AUGMENTED REALITY (WebXR)",
    color: "text-yellow-400",
    blocks: [
      {
        type: "paragraph",
        text: "Project Quantum Breach leverages the WebXR standard to deliver an Augmented Reality (AR) experience without requiring native app installation. This implementation utilizes the @react-three/xr library, bridging React Three Fiber with low-level WebXR APIs."
      },
      {
        type: "paragraph",
        text: "The core of the AR experience is the ability to detect physical surfaces (like tables or floors). We use WebXR's Hit-Test capability, where the device constantly casts rays from the camera into the real world to find intersection points with flat surfaces. In the ARPlacement.tsx component, the useXRHitTest hook receives the real-world position matrix every frame:"
      },
      {
        type: "code",
        language: "TYPESCRIPT",
        code: "useXRHitTest((results, getWorldMatrix) => {\n  if (isARPlaced) return; // Stop processing if game is placed\n\n  if (results.length > 0) {\n    // Get the matrix of the detected surface position\n    const hitMatrix = new THREE.Matrix4();\n    getWorldMatrix(hitMatrix, results[0]);\n\n    // Decompose the matrix to extract position and rotation\n    hitMatrix.decompose(\n      reticleRef.current.position,\n      reticleRef.current.quaternion,\n      reticleRef.current.scale\n    );\n  }\n}, 'viewer');"
      },
      {
        type: "paragraph",
        text: "To guide the user, a green reticle is designed to glide over detected surfaces. The placement process is divided into two stages:"
      },
      {
        type: "list",
        items: [
          "Ghost Mode: Before user confirmation, a semi-transparent version of the game board is displayed on the reticle, allowing the user to preview its scale and orientation.",
          "Anchoring: Upon screen tap, the game board's 3D position is 'frozen,' and the reticle disappears. From this point, the game board remains fixed relative to the real world, even if the user moves around the room."
        ]
      },
      {
        type: "card",
        title: "SCALE MANAGEMENT",
        content: "In 3D engines, units are abstract, but in AR, one unit equals one meter. A 6x6 game board rendered at default scale (1) would be 6 meters long! To solve this, the entire game scene is placed within a group with a scale of 0.04, making it approximately 24 cm to fit easily on a coffee table."
      },
      {
        type: "paragraph",
        text: "Technical Challenges and Interactions:"
      },
      {
        type: "list",
        items: [
          "Security Requirements (HTTPS): WebXR functionality only works in secure (HTTPS) contexts. GameSession.tsx includes a check to warn users on HTTP.",
          "Passthrough Rendering: The AR background must be transparent to show the device's camera feed. We manage this using gl={{ alpha: true }} on the Canvas and disabling Fog in the AR scene.",
          "Touch Interaction: Mouse click events don't work in AR. We use standard Pointer Events, translated by React Three Fiber into Raycasting in 3D space, allowing users to move pieces by tapping virtual gates on their mobile screen."
        ]
      }
    ]
  },
  {
    id: "rendering-optimization",
    title: "05 // RENDERING & GRAPHICAL OPTIMIZATION",
    color: "text-red-400",
    blocks: [
      {
        type: "paragraph",
        text: "One of the main priorities for Quantum Breach was high performance. Rendering a 3D scene in a web browser, especially on mobile devices with limited battery and processing power, requires specific techniques."
      },
      {
        type: "paragraph",
        text: "In the background scene (BackgroundScene.tsx) and the game grid lines, there are hundreds of geometric objects. If we created a separate Mesh for each, the number of 'Draw Calls' would drastically increase, bottlenecking the CPU. We used Geometry Instancing with <instancedMesh /> in Three.js, sending all background particles to the GPU with only one Draw Call. Position, rotation, and color changes for each particle are handled by direct matrix manipulation in a shared buffer."
      },
      {
        type: "paragraph",
        text: "In typical React applications, state changes trigger component re-renders. In a game where the state changes 60 times per second, this mechanism is too slow. We use the Zustand library for game state management (gameStore.ts). Its key feature allows state changes without triggering React's render cycle, enabling Three.js components (like useFrame) to directly read instantaneous values from the Store (Transient Updates). This eliminates lags caused by Garbage Collection and React Reconciliation."
      },
      {
        type: "paragraph",
        text: "When AR mode is activated, the system intelligently adjusts graphical settings:"
      },
      {
        type: "list",
        items: [
          "Disabling Anti-Aliasing (AA): On high-pixel-density mobile screens, AA has high overhead with minimal visual difference.",
          "Removing Background and Fog: To allow the real camera view and reduce GPU processing.",
          "Particle Management: The number of floating particles (Sparkles) is halved in AR mode."
        ]
      }
    ]
  },
  {
    id: "conclusion",
    title: "06 // CONCLUSION",
    color: "text-blue-500",
    blocks: [
      {
        type: "paragraph",
        text: "Project Quantum Breach exemplifies the capabilities of the modern web to deliver complex interactive experiences. By combining React for the user interface, Three.js for graphics, and Web Workers for heavy processing, we successfully built a strategic game with high-level AI that runs on a wide range of devices without installation."
      },
      {
        type: "paragraph",
        text: "This project demonstrates that classic computer science algorithms (like Minimax), when combined with cutting-edge web technologies (like WebXR and WebSockets), can create experiences that are both technically profound and visually engaging."
      }
    ]
  }
],
    back: "< TERMINATE SESSION >"
  },
  fa: {
    title: "ูุณุชู ุนุตุจ",
    subtitle: "ุชุญูู ุงูฺฏูุฑุชู // ูุณุฎู ด.ฐ",
    sections: [
  {
    id: "intro",
    title: "ฐฑ // ููุฏูู ู ูุนุฑู ูพุฑูฺู",
    color: "text-blue-400",
    blocks: [
      {
        type: "paragraph",
        text: "ูพุฑูฺู Quantum Breach ฺฉ ุจุงุฒ ุงุณุชุฑุงุชฺฺฉ ููุจุช (Turn-based Strategy) ุงุณุช ฺฉู ุจุง ุงููุงู ุงุฒ ููุงูู ูุญุงุณุจุงุช ฺฉูุงูุชูู ู ุงููุช ุณุงุจุฑ ุทุฑุงุญ ุดุฏู ุงุณุช. ุงู ูพุฑูฺู ุจุฑ ุฑู ูพูุชูุฑู ูุจ ุงุฌุฑุง ูโุดูุฏ ู ูุฏู ุขู ุงุฑุงุฆู ฺฉ ุชุฌุฑุจู ฺฏุฑุงูฺฉ ุณุทุญ ุจุงูุง (High-end) ุจุง ุงุณุชูุงุฏู ุงุฒ ุชฺฉููููฺโูุง ูุฏุฑู ูุจ ุงุณุช."
      },
      {
        type: "card",
        title: "ูพุดุชู ุชฺฉููููฺ (TECH STACK)",
        content: [
          "Frontend Framework: React 19 (ูุฏุฑุช UI ู State)",
          "3D Engine: Three.js + React Three Fiber (ุฑูุฏุฑูฺฏ ุณู ุจุนุฏ)",
          "State Management: Zustand (ูุฏุฑุช ูุถุนุช ุณุฑุงุณุฑ)",
          "Build Tool: Vite (ุจูุฏ ุณุฑุน ู HMR)",
          "Styling: Tailwind CSS (ุงุณุชุงูโุฏู ูุฏุฑู UI)",
          "Language: TypeScript (ุชุงูพโุฏู ุงุณุชุงุชฺฉ ุจุฑุง ุงููุช ฺฉุฏ)",
          "XR/AR: WebXR + React Three XR (ูุงูุนุช ุงูุฒูุฏู)",
          "Backend: Node.js + Express + Socket.io (ุณุฑูุฑ ฺูุฏููุฑู ุจูุงุฏุฑูฺฏ)"
        ]
      },
      {
        type: "paragraph",
        text: "ูุณุชู ุงุตู ุจุงุฒ ุจุฑ ุฑู ฺฉ ุดุจฺฉู ถรถ ุจูุง ุดุฏู ุงุณุช ฺฉู ุจุงุฒฺฉูุงู (Hacker vs AI/Security) ุชูุงุด ูโฺฉููุฏ ุจุง ุงุณุชูุงุฏู ุงุฒ ุณู ููุน ฺฏุช ููุทู (Firewall, Injector, Virus) ฺฉูุชุฑู ุจุชโูุง ฺฉูุงูุชูู (Qubits) ุฑุง ุฏุฑ ุฏุณุช ุจฺฏุฑูุฏ. ฺุงูุด ูู ุงุตู ุฏุฑ ุงู ูพุฑูฺูุ ูพุงุฏูโุณุงุฒ ฺฉ ููุด ูุตููุน ูุฏุฑุชููุฏ ุฏุฑ ูุฑูุฑฺฏุฑ ุจุฏูู ูุณุฏูุฏ ฺฉุฑุฏู ุชุฑุฏ ุงุตู (Main Thread) ู ููฺูู ุงุฌุงุฏ ฺฉ ุชุฌุฑุจู ฺูุฏููุฑู ุจุฏูู ุชุงุฎุฑ ุจุง ุงุณุชูุงุฏู ุงุฒ ููฺฏุงูโุณุงุฒ ูุทุน ุจูุฏู ุงุณุช."
      }
    ]
  },
  {
    id: "ai-minimax",
    title: "ฐฒ // ูุณุชู ุนุตุจ: ุชุญูู ููโูุงฺฉุณ",
    color: "text-green-400",
    blocks: [
      {
        type: "paragraph",
        text: "ูุบุฒ ูุชูฺฉุฑ ุจุงุฒ Quantum Breach ฺฉ ููุชูุฑ ููุด ูุตููุน ุณูุงุฑุด ุงุณุช ฺฉู ุจุฑ ูพุงู ุงูฺฏูุฑุชู Minimax ููุฑุงู ุจุง ูุฑุณ ุขููุง-ุจุชุง (Alpha-Beta Pruning) ุจูุง ุดุฏู ุงุณุช. ุจุฑุฎูุงู ุจุณุงุฑ ุงุฒ ุจุงุฒโูุง ูุจ ฺฉู ุงุฒ ููุทูโูุง ุณุงุฏู \"if-else\" ุงุณุชูุงุฏู ูโฺฉููุฏุ ุงู AI ุฏุฑุฎุช ุจุงุฒ ุฑุง ุชุง ุนูู ูุดุฎุต (ุจู ด ุชุง ถ ูุงู ุจุณุชู ุจู ุณุฎุช) ุดุจูโุณุงุฒ ูโฺฉูุฏ."
      },
      {
        type: "paragraph",
        text: "ุจุฑุง ุงูฺฉู ููุด ูุตููุน ุจุชูุงูุฏ ุจู ูุถุนุชโูุง ยซุฎูุจยป ู ยซุจุฏยป ุชูุงุฒ ูุงุฆู ุดูุฏุ ุงุฒ ฺฉ ุชุงุจุน ุงุฑุฒุงุจ (Evaluation Function) ูุทุน ุงุณุชูุงุฏู ูโฺฉูุฏ. ุงู ุชุงุจุน ุจู ูุฑ ูุถุนุช ุตูุญู (s) ฺฉ ุงูุชุงุฒ ุนุฏุฏ U(s) ูุณุจุช ูโุฏูุฏ:"
      },
      {
        type: "formula",
        math: "U(s) = (W_m ยท M(s)) + (W_p ยท P(s)) + (W_c ยท C(s)) - (W_t ยท T(s))"
      },
      {
        type: "list",
        items: [
          "M(s) (Material): ุงุฑุฒุด ุฎุงูุต ููุฑูโูุง. ฺฏุชโูุง ููู ุดุฏู (Locked) ุจู ุฏูู ูููุฐูุงูพุฐุฑุ ุถุฑุจ ณ ุจุฑุงุจุฑ ูุณุจุช ุจู ฺฏุชโูุง ูุนููู (Stable) ุฏุงุฑูุฏ.",
          "P(s) (Positional): ุงุฑุฒุด ูููุนุช ุจุฑ ุงุณุงุณ Heatmap. ุฎุงููโูุง ูุฑฺฉุฒ ุตูุญู ุงุฑุฒุด ุงุณุชุฑุงุชฺฺฉ ุจุงูุงุชุฑ ุฏุงุฑูุฏ ุฒุฑุง ุฏุณุชุฑุณ ุจู ููุณุงฺฏุงู ุจุดุชุฑ ุฑุง ูุฑุงูู ูโฺฉููุฏ.",
          "C(s) (Clustering): ุงูุชุงุฒ ุฎูุดูโุจูุฏ. ููุด ูุตููุน ุจุฑุง ุงุฌุงุฏ ุฒูุฌุฑูโุง ุงุฒ ููุฑูโูุง ูุชุตู ุจู ูู ูพุงุฏุงุด ูโฺฏุฑุฏ (ุฏูุงุน ุฌูุน).",
          "T(s) (Threats): ุฌุฑูู ุจุฑุง ุชูุฏุฏุงุช ุญุฑู. ุงฺฏุฑ ููุฑูโูุง ุญุฑู ุฏุฑ ูููุนุช ุญููู ูุฑุงุฑ ุฏุงุดุชู ุจุงุดูุฏุ ุงูุชุงุฒ ฺฉุณุฑ ูโุดูุฏ."
        ]
      },
      {
        type: "card",
        title: "ูพุงุฏูโุณุงุฒ HEATMAP",
        content: "ุขุฑุงู ุฒุฑ ฺฉู ุฏุฑ ฺฉุฏ minimax.worker.ts ุชุนุฑู ุดุฏู ุงุณุชุ ุงุฑุฒุด ุฐุงุช ูุฑ ุฎุงูู ุงุฒ ุดุจฺฉู ถรถ ุฑุง ูุดุงู ูโุฏูุฏ. ุงุนุฏุงุฏ ุจุฒุฑฺฏุชุฑ (12) ูุดุงูโุฏููุฏู ูุฑฺฉุฒ ุตูุญู ู ุงุนุฏุงุฏ ฺฉูฺฺฉุชุฑ (2) ูุดุงูโุฏููุฏู ฺฏูุดูโูุง ฺฉูโุงุฑุฒุด ูุณุชูุฏ."
      },
      {
        type: "code",
        language: "TYPESCRIPT",
        code: "const POSITION_VALUES = new Int8Array([\n  2,  3,  4,  4,  3,  2,\n  3,  6,  8,  8,  6,  3,\n  4,  8, 12, 12,  8,  4,\n  4,  8, 12, 12,  8,  4,\n  3,  6,  8,  8,  6,  3,\n  2,  3,  4,  4,  3,  2\n]);"
      },
      {
        type: "paragraph",
        text: "ฺฉ ุงุฒ ฺุงูุดโูุง ุงุตู ุฏุฑ Quantum Breachุ ูุฌูุฏ ฺฏุช Injector (X) ุงุณุช ฺฉู ุฏุฑ ุญููุงุช ูุทุฑ ตฐูช ุงุญุชูุงู ุดฺฉุณุช ุฏุงุฑุฏ. ุงูฺฏูุฑุชู Minimax ฺฉูุงุณฺฉ ุจุฑุง ุจุงุฒโูุง ูุทุน (Deterministic) ุทุฑุงุญ ุดุฏู ุงุณุช. ุจุฑุง ุญู ุงู ูุดฺฉูุ ูุง ุงุฒ ููููู ุงูุฏ ุฑุงุถ ูุทููุจุช (Expected Utility) ุงุณุชูุงุฏู ฺฉุฑุฏูโุงู. ููฺฏุงู ฺฉู ููุด ูุตููุน ุญุฑฺฉุช ุฑุง ุจุฑุฑุณ ูโฺฉูุฏ ฺฉู ุดุงูู ุดุงูุณ ุงุณุชุ ุดุงุฎู ุฏุฑุฎุช ุจุงุฒ ุจู ุฏู ุฒุฑุดุงุฎู ุชูุณู ูโุดูุฏ:"
      },
      {
        type: "formula",
        math: "EU(action) = ฮฃ P(outcome_i) ร U(outcome_i)"
      },
      {
        type: "formula",
        math: "EU = (0.5 ร U_success) + (0.5 ร U_fail)"
      },
      {
        type: "paragraph",
        text: "ููุด ูุตููุน ุฏุงุฑุง ฺฉ ยซูููยป ุงุฒ ูฺฉุงูฺฉ ูุฑููพุงุด ฺฉูุงูุชูู (Quantum Collapse) ุจุงุฒ ุงุณุช. ุงู ููุถูุน ุฏุฑ ูุญูู ุงุณุชูุงุฏู ุงุฒ ฺฏุชโูุง Virus (H) ู Firewall (Z) ูููุฏ ูพุฏุง ูโฺฉูุฏ:"
      },
      {
        type: "list",
        items: [
          "ุงุณุชุฑุงุชฺ ุจุฑุฏ (Winning State): ุงฺฏุฑ AI ุฌูู ุจุงุดุฏุ ูุฏูุด ฺฉุงูุด ูุงุฑุงูุณ ุงุณุช. ุงู ุงุฒ Firewall ุงุณุชูุงุฏู ูโฺฉูุฏ ุชุง ูุถุนุช ุฑุง ุชุซุจุช ฺฉุฑุฏู ู ุดุงูุณ ุจุงุฒฺฏุดุช ุญุฑู ุฑุง ุจู ุตูุฑ ุจุฑุณุงูุฏ.",
          "ุงุณุชุฑุงุชฺ ุจุงุฎุช (Losing State): ุงฺฏุฑ AI ุนูุจ ุจุงุดุฏุ ูุฏูุด ุงูุฒุงุด ูุงุฑุงูุณ ุงุณุช. ุงู ุงุฒ Virus ุงุณุชูุงุฏู ูโฺฉูุฏ ุชุง ููุฑูโูุง ูพุงุฏุงุฑ ุญุฑู ุฑุง ุจู ุญุงูุช Flux (ูุงูพุงุฏุงุฑ) ุจุจุฑุฏ. ุงู ฺฉุงุฑ ูุชุฌู ูุทุน ุจุงุฎุช ุฑุง ุจู ฺฉ ููุงุฑ ตฐ/ตฐ ุชุจุฏู ูโฺฉูุฏ."
        ]
      },
      {
        type: "paragraph",
        text: "ูุญุงุณุจุงุช Minimax ุจุณุงุฑ ุณูฺฏู ูุณุชูุฏ. ุจุฑุง ุฌููฺฏุฑ ุงุฒ ูุฑุฒ ุดุฏู ุฑุงุจุท ฺฉุงุฑุจุฑ (UI) ู ุฑุณุฏู ุจู ุณุฑุนุช ถฐ ูุฑู ุจุฑ ุซุงููุ ูุนูุงุฑ ุฒุฑ ูพุงุฏูโุณุงุฒ ุดุฏู ุงุณุช:"
      },
      {
        type: "list",
        items: [
          "Web Worker ุงุฎุชุตุงุต: ุชูุงู ููุทู ูุญุงุณุจุงุช ุฏุฑ ฺฉ ุชุฑุฏ ุฌุฏุงฺฏุงูู ุงุฌุฑุง ูโุดูุฏ.",
          "ุขุฑุงูโูุง ููุนโุฏุงุฑ (TypedArrays): ุจู ุฌุง ุงุณุชูุงุฏู ุงุฒ ุขุฑุงูโูุง ูุนููู ุฌุงูุงุงุณฺฉุฑูพุชุ ุงุฒ Int8Array ุจุฑุง ููุงุด ุตูุญู ุจุงุฒ ุงุณุชูุงุฏู ุดุฏู ุงุณุช.",
          "ฺฉุด ููุณุงฺฏุงู (Neighbors Cache): ูุณุช ููุณุงฺฏุงู ูุฑ ุณููู (ฺฉู ุซุงุจุช ุงุณุช) ุฏุฑ ุดุฑูุน ุจุงุฒ ูพุดโูุญุงุณุจู ุดุฏู ู ุฐุฎุฑู ูโุดูุฏ."
        ]
      },
      {
        type: "card",
        title: "ุชฺฉูฺฉ TRANSFERABLE OBJECTS",
        content: "ููฺฏุงู ุงุฑุณุงู ุฏุงุฏูโูุง ุจู Thread ุงุตู ู Workerุ ุงุฒ ุชฺฉูฺฉ Transferable Objects ุงุณุชูุงุฏู ุดุฏู ุงุณุช. ุงู ุนู ุจุงูุฑ ุญุงูุธู (Buffer) ุจู ุฌุง ฺฉูพ ุดุฏูุ ูุณุชููุงู ุจู Worker ููุชูู ูโุดูุฏ ฺฉู ุณุฑุจุงุฑ (Overhead) ุงุฑุชุจุงุท ุฑุง ุจู ูุฒุฏฺฉ ุตูุฑ ูโุฑุณุงูุฏ."
      }
    ]
  },
  {
    id: "multiplayer",
    title: "ฐณ // ูุนูุงุฑ ุดุจฺฉู: ููฺฏุงูโุณุงุฒ ูุทุน",
    color: "text-purple-400",
    blocks: [
      {
        type: "paragraph",
        text: "ุจุฎุด ฺูุฏููุฑู ุจุงุฒ Quantum Breach ุจุฑ ูพุงู ูพุฑูุชฺฉู WebSocket (ุจุง ุงุณุชูุงุฏู ุงุฒ ฺฉุชุงุจุฎุงูู Socket.io) ูพุงุฏูโุณุงุฒ ุดุฏู ุงุณุช. ุณุฑูุฑ ุจุงุฒ (ููุดุชู ุดุฏู ุจุง Node.js) ูุธูู ูุฏุฑุช ุงุชุงูโูุง (Rooms)ุ ุงุชุตุงู ุจุงุฒฺฉูุงู (Matchmaking) ู ุฑูู ฺฉุฑุฏู ูพุงูโูุง ุฑุง ุจุฑ ุนูุฏู ุฏุงุฑุฏุ ุงูุง ููุทู ูุฒฺฉ ู ูุญุงุณุจุงุช ุจุงุฒ ุฏุฑ ุณูุช ฺฉูุงูุช (Client-side) ุงูุฌุงู ูโุดูุฏ."
      },
      {
        type: "paragraph",
        text: "ฺฉ ุงุฒ ฺุงูุดโูุง ุจุงุฒโูุง ุขููุงูุ ููฺฏุงู ูฺฏู ุฏุงุดุชู ูุถุนุช ุจุงุฒ ุจู ุฏู ุจุงุฒฺฉู ุงุณุช. ุจู ุฌุง ุงุฑุณุงู ฺฉู ูุถุนุช ุตูุญู (ฺฉู ุดุงูู ณถ ุขุจุฌฺฉุช ูพฺุฏู ุงุณุช) ุฏุฑ ูุฑ ูุฑูุ ูุง ุงุฒ ุงูฺฏู Input Streaming ุงุณุชูุงุฏู ฺฉุฑุฏูโุงู. ุฏุฑ ุงู ุฑูุดุ ุชููุง ยซูุฑูุฏโูุง ฺฉุงุฑุจุฑยป ู ฺฉ ยซSeed ุชุตุงุฏูยป ุงุฑุณุงู ูโุดูุฏ."
      },
      {
        type: "card",
        title: "ููุด SEED ุฏุฑ ููฺฏุงูโุณุงุฒ RNG",
        content: "ุจุงุฒ ุฏุงุฑุง ุงููุงูโูุง ุดุงูุณ ุงุณุช. ุจุฑุง ุญู ูุดฺฉู Desyncุ ฺฉูุงูุช ุดุฑูุนโฺฉููุฏู ุญุฑฺฉุชุ ฺฉ seed ุชุตุงุฏู ุชููุฏ ฺฉุฑุฏู ู ููุฑุงู ุญุฑฺฉุช ุงุฑุณุงู ูโฺฉูุฏ. ูุฑ ุฏู ฺฉูุงูุช ุงุฒ ฺฉ ุชุงุจุน PRNG ุณูุงุฑุด (ูุงููุฏ mulberry32) ุงุณุชูุงุฏู ูโฺฉููุฏ ฺฉู ุจุง ุฏุฑุงูุช ุงู Seedุ ุฏูุจุงููโุง ุงุฒ ุงุนุฏุงุฏ ุชุตุงุฏู ฺฉุงููุงู ูุดุงุจู ุชููุฏ ูโฺฉูุฏ."
      },
      {
        type: "code",
        language: "TYPESCRIPT",
        code: "// QuantumLogic.ts\nexport const mulberry32 = (a: number) => {\n  return () => {\n    let t = a += 0x6D2B79F5;\n    t = Math.imul(t ^ (t >>> 15), t | 1);\n    // ... ูุญุงุณุจุงุช ุจุช ุจุฑุง ุชููุฏ ุนุฏุฏ ุดุจูโุชุตุงุฏู\n    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;\n  }\n};"
      },
      {
        type: "paragraph",
        text: "ุจุฑุง ุจูููโุณุงุฒ ูพููุง ุจุงูุฏุ ูพุงูโูุง ุชุจุงุฏู ุดุฏู ุจุณุงุฑ ฺฉูโุญุฌู ูุณุชูุฏ. ฺฉ ุจุณุชู ุฏุงุฏู ูุนููู ุจุฑุง ุงูุฌุงู ุญุฑฺฉุช ุจู ุดฺฉู ุฒุฑ ุงุณุช:"
      },
      {
        type: "code",
        language: "TYPESCRIPT",
        code: "interface MovePayload {\n  roomId: string;  // ุดูุงุณู ุงุชุงู ุจุงุฒ\n  nodeId: number;  // ุงูุฏฺฉุณ ุณููู (0 ุชุง 35)\n  gate: 'Z' | 'X' | 'H'; // ููุน ฺฏุช ุงุณุชูุงุฏู ุดุฏู\n  seed: number;    // ุนุฏุฏ ุจุฐุฑ ุจุฑุง ููฺฏุงูโุณุงุฒ ุดุงูุณ\n}"
      },
      {
        type: "paragraph",
        text: "ุงฺฏุฑฺู ูุญุงุณุจุงุช ุฏุฑ ฺฉูุงูุช ุงูุฌุงู ูโุดูุฏุ ุณุฑูุฑ (server/index.js) ููุด ยซุญููุช ูุฑุฌุนยป (Authoritative Source) ุฑุง ุจุฑุง ููุงูู ูพุงู ุงูุง ูโฺฉูุฏ:"
      },
      {
        type: "list",
        items: [
          "ุจุฑุฑุณ ููุจุช (Turn Validation): ุณุฑูุฑ ฺฺฉ ูโฺฉูุฏ ฺฉู ุขุง ูุงูุนุงู ููุจุช ุจุงุฒฺฉู ุงุณุช ฺฉู ุฏุฑุฎูุงุณุช ุฑุง ุงุฑุณุงู ฺฉุฑุฏู ุง ุฎุฑ.",
          "ุจุฑุฑุณ ููุงูู ุญุฑฺฉุช: ุณุฑูุฑ ุงุทููุงู ุญุงุตู ูโฺฉูุฏ ฺฉู ุณููู ููุตุฏ ุฎุงู ุงุณุช ู ููุน ฺฏุช ูุนุชุจุฑ ุงุณุช.",
          "ูุญุฏูุฏุช ูุฑุฎ (Rate Limiting): ุจุฑุง ุฌููฺฏุฑ ุงุฒ ุญููุงุช Spam ุง DoSุ ุณุฑูุฑ ุชุนุฏุงุฏ ุฏุฑุฎูุงุณุชโูุง ุฏุฑ ุซุงูู ุฑุง ุจุฑุง ูุฑ ุณูฺฉุช ูุญุฏูุฏ ูโฺฉูุฏ."
        ]
      },
      {
        type: "paragraph",
        text: "ุณุณุชู ุฏุงุฑุง ูฺฉุงูุฒูโูุง ุจุงุฒุงุจ (Reconnection) ุงุณุช. ุงฺฏุฑ ุงุฑุชุจุงุท ฺฉ ุจุงุฒฺฉู ูุทุน ุดูุฏ:"
      },
      {
        type: "list",
        items: [
          "ุณุฑูุฑ ุฑูุฏุงุฏ player_left ุฑุง ุจุฑูุฏฺฉุณุช ูโฺฉูุฏ.",
          "ฺฉูุงูุช ููุงุจู ูุงุฑุฏ ุญุงูุช ยซุงูุชุธุงุฑยป ุดุฏู ู UI ูุถุนุช Signal Lost ุฑุง ููุงุด ูโุฏูุฏ.",
          "ฺฉูุงูุช ูุทุน ุดุฏู ุจู ุตูุฑุช ุฎูุฏฺฉุงุฑ ุชูุงุด ูโฺฉูุฏ ุชุง ต ุจุงุฑ ูุฌุฏุฏุงู ูุชุตู ุดูุฏ.",
          "ุงฺฏุฑ ุงุชุตุงู ุจุฑูุฑุงุฑ ูุดูุฏุ ุจุงุฒ ุฎุงุชูู ูโุงุจุฏ."
        ]
      }
    ]
  },
{
    id: "ar-webxr",
    title: "ฐด // ูพุงุฏูโุณุงุฒ ูุงูุนุช ุงูุฒูุฏู (WebXR)",
    color: "text-yellow-400",
    blocks: [
      {
        type: "paragraph",
        text: "ูพุฑูฺู Quantum Breach ุงุฒ ุงุณุชุงูุฏุงุฑุฏ WebXR ุจุฑุง ุงุฑุงุฆู ุชุฌุฑุจู ูุงูุนุช ุงูุฒูุฏู (AR) ุจุฏูู ูุงุฒ ุจู ูุตุจ ุงูพูฺฉุดู ุจูู ุงุณุชูุงุฏู ูโฺฉูุฏ. ุงู ูพุงุฏูโุณุงุฒ ุจุง ุงุณุชูุงุฏู ุงุฒ ฺฉุชุงุจุฎุงูู @react-three/xr ุงูุฌุงู ุดุฏู ุงุณุช ฺฉู ูพู ูุงู React Three Fiber ู APIูุง ุณุทุญ ูพุงู WebXR ุงุฌุงุฏ ูโฺฉูุฏ."
      },
      {
        type: "paragraph",
        text: "ูุณุชู ุงุตู ุชุฌุฑุจู ARุ ูุงุจูุช ุชุดุฎุต ุณุทูุญ ูุฒฺฉ (ูุงููุฏ ูุฒ ุง ุฒูู) ุงุณุช. ูุง ุงุฒ ูุงุจูุช Hit-Test ุฏุฑ WebXR ุงุณุชูุงุฏู ูโฺฉูู. ุฏุฑ ฺฉุงููพูููุช ARPlacement.tsxุ ููฺฉ useXRHitTest ูุงุชุฑุณ ูููุนุช ุฏูุง ูุงูุน ุฑุง ุฏุฑ ูุฑ ูุฑู ุฏุฑุงูุช ูโฺฉูุฏ:"
      },
      {
        type: "code",
        language: "TYPESCRIPT",
        code: "useXRHitTest((results, getWorldMatrix) => {\n  if (isARPlaced) return; // ุงฺฏุฑ ุจุงุฒ ุดุฑูุน ุดุฏูุ ูพุฑุฏุงุฒุด ูุชููู ุดูุฏ\n\n  if (results.length > 0) {\n    // ุฏุฑุงูุช ูุงุชุฑุณ ูููุนุช ุณุทุญ ุชุดุฎุต ุฏุงุฏู ุดุฏู\n    const hitMatrix = new THREE.Matrix4();\n    getWorldMatrix(hitMatrix, results[0]);\n\n    // ุชุฌุฒู ูุงุชุฑุณ ุจุฑุง ุงุณุชุฎุฑุงุฌ ูููุนุช ู ฺุฑุฎุด\n    hitMatrix.decompose(\n      reticleRef.current.position,\n      reticleRef.current.quaternion,\n      reticleRef.current.scale\n    );\n  }\n}, 'viewer');"
      },
      {
        type: "paragraph",
        text: "ุจุฑุง ุฑุงูููุง ฺฉุงุฑุจุฑุ ฺฉ ุญููู ุณุจุฒ ุฑูฺฏ (Reticle) ุทุฑุงุญ ุดุฏู ฺฉู ุฑู ุณุทูุญ ุชุดุฎุต ุฏุงุฏู ุดุฏู ูโูุบุฒุฏ. ูุฑุขูุฏ ุฌุงฺฏุฐุงุฑ ุจู ุฏู ูุฑุญูู ุชูุณู ูโุดูุฏ:"
      },
      {
        type: "list",
        items: [
          "ุญุงูุช ุดุจุญ (Ghost Mode): ูุจู ุงุฒ ุชุงุฏ ฺฉุงุฑุจุฑุ ฺฉ ูุณุฎู ูููโุดูุงู ุงุฒ ุตูุญู ุจุงุฒ ุฑู ุฑุชฺฉู ููุงุด ุฏุงุฏู ูโุดูุฏ ุชุง ฺฉุงุฑุจุฑ ููุงุณ ู ุฌูุช ุขู ุฑุง ุจุจูุฏ.",
          "ููู ุดุฏู (Anchoring): ุจุง ููุณ ุตูุญู (Tap)ุ ูููุนุช ุตูุญู ุจุงุฒ ุฏุฑ ูุถุง ุณู ุจุนุฏ ยซูููยป (Freeze) ูโุดูุฏ ู ุฑุชฺฉู ูุงูพุฏุฏ ูโฺฏุฑุฏุฏ. ุงุฒ ุงู ูุญุธู ุจู ุจุนุฏุ ุตูุญู ุจุงุฒ ูุณุจุช ุจู ุฏูุง ูุงูุน ุซุงุจุช ูโูุงูุฏ."
        ]
      },
      {
        type: "card",
        title: "ูุฏุฑุช ููุงุณ (SCALE MANAGEMENT)",
        content: "ุฏุฑ ููุชูุฑูุง ุณู ุจุนุฏุ ูุงุญุฏูุง ุงูุชุฒุงุน ูุณุชูุฏุ ุงูุง ุฏุฑ AR ูุฑ ูุงุญุฏ ูุนุงุฏู ฺฉ ูุชุฑ ุงุณุช. ุตูุญู ุจุงุฒ ถรถ ุงฺฏุฑ ุจุง ููุงุณ ูพุดโูุฑุถ (ฑ) ุฑูุฏุฑ ุดูุฏุ ถ ูุชุฑ ุทูู ุฎูุงูุฏ ุฏุงุดุช! ุจุฑุง ุญู ุงู ูุดฺฉูุ ฺฉู ุตุญูู ุจุงุฒ ุฏุฑูู ฺฉ ฺฏุฑูู ุจุง ููุงุณ 0.04 ูุฑุงุฑ ฺฏุฑูุชู ุงุณุช ุชุง ุงูุฏุงุฒู ุขู ุญุฏูุฏ ฒด ุณุงูุชโูุชุฑ ุดูุฏ ู ุจู ุฑุงุญุช ุฑู ฺฉ ูุฒ ููููโุฎูุฑ ุฌุง ุจฺฏุฑุฏ."
      },
      {
        type: "paragraph",
        text: "ฺุงูุดโูุง ูู ู ุชุนุงููุงุช:"
      },
      {
        type: "list",
        items: [
          "ุงูุฒุงูุงุช ุงููุช (HTTPS): ุทุจู ุงุณุชุงูุฏุงุฑุฏ W3Cุ ูุงุจูุช WebXR ุชููุง ุฏุฑ ูุญุทโูุง ุงูู (HTTPS) ฺฉุงุฑ ูโฺฉูุฏ. ุฏุฑ GameSession.tsx ฺฉ ฺฺฉ ุงููุช ูุฑุงุฑ ุฏุงุฏู ุดุฏู ุชุง ุงฺฏุฑ ฺฉุงุฑุจุฑ ุฑู HTTP ุจุงุดุฏุ ูุดุฏุงุฑ ุฏุฑุงูุช ฺฉูุฏ.",
          "ุฑูุฏุฑูฺฏ Passthrough: ูพุณโุฒููู ุฏุฑ ุญุงูุช AR ุจุงุฏ ุดูุงู (Transparent) ุจุงุดุฏ. ูุง ุจุง ุงุณุชูุงุฏู ุงุฒ ูพุฑุงูพ gl={{ alpha: true }} ุฏุฑ Canvas ู ุบุฑูุนุงู ฺฉุฑุฏู Fog ุฏุฑ ุตุญูู ARุ ุงู ููุถูุน ุฑุง ูุฏุฑุช ฺฉุฑุฏูโุงู.",
          "ุชุนุงูู ููุณ: ุฑูุฏุงุฏูุง ฺฉูฺฉ ูุงูุณ ุฏุฑ AR ฺฉุงุฑ ููโฺฉููุฏ. ูุง ุงุฒ ุฑูุฏุงุฏูุง ุงุณุชุงูุฏุงุฑุฏ Pointer Events ุงุณุชูุงุฏู ฺฉุฑุฏูโุงู ฺฉู ุชูุณุท React Three Fiber ุจู Raycasting ุชุฑุฌูู ูโุดููุฏ ุชุง ฺฉุงุฑุจุฑ ุจุชูุงูุฏ ุจุง ููุณ ฺฉุฑุฏู ฺฏุชโูุง ูุฌุงุฒ ุฑู ุตูุญู ููุจุงูุ ููุฑูโูุง ุฑุง ุฌุงุจุฌุง ฺฉูุฏ."
        ]
      }
    ]
  },
  {
    id: "rendering-optimization",
    title: "ฐต // ุฑูุฏุฑูฺฏ ู ุจูููโุณุงุฒ ฺฏุฑุงูฺฉ",
    color: "text-red-400",
    blocks: [
      {
        type: "paragraph",
        text: "ฺฉ ุงุฒ ุงูููุชโูุง ุงุตู ูพุฑูฺู Quantum Breachุ ุนููฺฉุฑุฏ ุจุงูุง (Performance) ุจูุฏู ุงุณุช. ุฑูุฏุฑ ฺฉุฑุฏู ฺฉ ุตุญูู ุณู ุจุนุฏ ุฏุฑ ูุฑูุฑฺฏุฑ ูุจุ ุจูโูฺู ุฏุฑ ุฏุณุชฺฏุงูโูุง ููุจุงู ุจุง ูุญุฏูุฏุช ุจุงุชุฑ ู ูพุฑุฏุงุฒุดฺฏุฑุ ูุงุฒููุฏ ุชฺฉูฺฉโูุง ุฎุงุต ุงุณุช."
      },
      {
        type: "paragraph",
        text: "ุฏุฑ ุตุญูู ูพุณโุฒููู (BackgroundScene.tsx) ู ุฎุทูุท ุดุจฺฉู ุจุงุฒุ ุตุฏูุง ุขุจุฌฺฉุช ููุฏุณ ูุฌูุฏ ุฏุงุฑุฏ. ูุง ุงุฒ ุชฺฉูฺฉ Geometry Instancing ุงุณุชูุงุฏู ฺฉุฑุฏูโุงู. ุจุง ุงุณุชูุงุฏู ุงุฒ <instancedMesh /> ุฏุฑ Three.jsุ ุชูุงู ุฐุฑุงุช ูพุณโุฒููู ุชููุง ุจุง ฺฉ Draw Call ุจู GPU ุงุฑุณุงู ูโุดููุฏ. ุชุบุฑุงุช ูููุนุชุ ฺุฑุฎุด ู ุฑูฺฏ ูุฑ ุฐุฑู ุงุฒ ุทุฑู ุฏุณุชฺฉุงุฑ ูุณุชูู ูุงุชุฑุณโูุง ุฏุฑ ฺฉ ุจุงูุฑ ุงุดุชุฑุงฺฉ ุงูุฌุงู ูโุดูุฏ."
      },
      {
        type: "paragraph",
        text: "ุฏุฑ ุจุฑูุงููโูุง React ูุนูููุ ุชุบุฑ State ุจุงุนุซ ุฑูุฏุฑ ูุฌุฏุฏ ูโุดูุฏ. ูุง ุงุฒ ฺฉุชุงุจุฎุงูู Zustand ุจุฑุง ูุฏุฑุช ูุถุนุช ุจุงุฒ (gameStore.ts) ุงุณุชูุงุฏู ฺฉุฑุฏูโุงู. ูฺฺฏ ฺฉูุฏ ุขู ุงู ุงุณุช ฺฉู ุงุฌุงุฒู ูโุฏูุฏ ุชุบุฑุงุช ุฑุง ุจุฏูู ุชุญุฑฺฉ ฺุฑุฎู ุฑูุฏุฑ React ุงูุฌุงู ุฏูู ู ฺฉุงููพูููุชโูุง Three.js (ูุงููุฏ useFrame) ูโุชูุงููุฏ ูุณุชููุงู ููุฏุงุฑ ูุญุธูโุง ุฑุง ุงุฒ Store ุจุฎูุงููุฏ (Transient Updates)."
      },
      {
        type: "paragraph",
        text: "ููฺฏุงู ฺฉู ุญุงูุช AR ูุนุงู ูโุดูุฏุ ุณุณุชู ุจู ุทูุฑ ููุดููุฏ ุชูุธูุงุช ฺฏุฑุงูฺฉ ุฑุง ุชุบุฑ ูโุฏูุฏ:"
      },
      {
        type: "list",
        items: [
          "ุบุฑูุนุงู ฺฉุฑุฏู Anti-Aliasing (AA): ุฏุฑ ุตูุญุงุช ููุจุงู ุจุง ุชุฑุงฺฉู ูพฺฉุณู ุจุงูุงุ AA ุณุฑุจุงุฑ ุฒุงุฏ ุฏุงุฑุฏ ู ุชูุงูุช ุจุตุฑ ฺฉู ุงุฌุงุฏ ูโฺฉูุฏ.",
          "ุญุฐู ูพุณโุฒููู ู ูู (Fog): ุจุฑุง ุงูฺฉู ุฏูุฑุจู ูุงูุน ุฏุฏู ุดูุฏ ู ูพุฑุฏุงุฒุด GPU ฺฉุงูุด ุงุจุฏ.",
          "ูุฏุฑุช ุฐุฑุงุช: ุชุนุฏุงุฏ ุฐุฑุงุช ูุนูู (Sparkles) ุฏุฑ ุญุงูุช AR ุจู ูุตู ฺฉุงูุด ูโุงุจุฏ."
        ]
      }
    ]
  },
  {
    id: "conclusion",
    title: "ฐถ // ูุชุฌูโฺฏุฑ",
    color: "text-blue-500",
    blocks: [
      {
        type: "paragraph",
        text: "ูพุฑูฺู Quantum Breach ูููููโุง ุงุฒ ุชูุงูุงโูุง ูุฏุฑู ูุจ ุจุฑุง ุงุฑุงุฆู ุชุฌุฑุจุงุช ุชุนุงูู ูพฺุฏู ุงุณุช. ุจุง ุชุฑฺฉุจ React ุจุฑุง ุฑุงุจุท ฺฉุงุฑุจุฑุ Three.js ุจุฑุง ฺฏุฑุงูฺฉ ู Web Workers ุจุฑุง ูพุฑุฏุงุฒุดโูุง ุณูฺฏูุ ูุง ูููู ุดุฏู ฺฉ ุจุงุฒ ุงุณุชุฑุงุชฺฺฉ ุจุง ููุด ูุตููุน ุณุทุญ ุจุงูุง ุจุณุงุฒู ฺฉู ุจุฏูู ูุงุฒ ุจู ูุตุจุ ุฑู ุทู ูุณุน ุงุฒ ุฏุณุชฺฏุงูโูุง ุงุฌุฑุง ูโุดูุฏ."
      },
      {
        type: "paragraph",
        text: "ุงู ูพุฑูฺู ูุดุงู ูโุฏูุฏ ฺฉู ุงูฺฏูุฑุชูโูุง ฺฉูุงุณฺฉ ุนููู ฺฉุงููพูุชุฑ (ูุงููุฏ Minimax) ููุช ุจุง ุชฺฉููููฺโูุง ููู ูุจ (ูุงููุฏ WebXR ู WebSockets) ุชุฑฺฉุจ ุดููุฏุ ูโุชูุงููุฏ ุชุฌุฑุจุงุช ุฎูู ฺฉููุฏ ฺฉู ูู ุงุฒ ูุธุฑ ูู ุนูู ู ูู ุงุฒ ูุธุฑ ุจุตุฑ ุฌุฐุงุจ ูุณุชูุฏ."
      }
    ]
  }
],
    back: "< ูพุงุงู ุฌูุณู >"
  }
};

const MinimaxInfo = () => {
  const [lang, setLang] = useState<Lang>('en');

  // Helper function to render specific block types
  const renderBlock = (block: ContentBlock, index: number) => {
    switch (block.type) {
      case 'paragraph':
        return (
          <p key={index} className="text-sm md:text-base leading-relaxed text-gray-300 whitespace-pre-line mb-4">
            {block.text}
          </p>
        );

      case 'code':
        return (
          <div key={index} className="my-6 rounded bg-black/50 border border-white/10 p-4 overflow-hidden font-mono text-xs md:text-sm shadow-inner relative group">
            {block.language && (
              <div className="absolute top-0 right-0 px-2 py-1 bg-white/10 text-[10px] text-gray-400 uppercase tracking-wider rounded-bl">
                {block.language}
              </div>
            )}
            <pre className="overflow-x-auto custom-scrollbar text-green-400/90 leading-normal" dir="ltr">
              <code>{block.code}</code>
            </pre>
          </div>
        );

      case 'formula':
        return (
          <div key={index} className="my-6 py-4 px-2 flex justify-center items-center bg-white/5 border-y border-white/5" dir="ltr">
            <span className="font-serif italic text-lg md:text-xl text-purple-200 tracking-wide text-center">
              {block.math}
            </span>
          </div>
        );

      case 'list':
        return (
          <ul key={index} className="space-y-2 mb-6 pl-2">
            {block.items.map((item, i) => (
              <li key={i} className="flex items-start gap-3 text-sm md:text-base text-gray-300">
                <span className="mt-1.5 w-1.5 h-1.5 bg-purple-500 rounded-full shrink-0 shadow-[0_0_5px_rgba(168,85,247,0.5)]"></span>
                <span>{item}</span>
              </li>
            ))}
          </ul>
        );

      case 'card':
        return (
          <div key={index} className="my-6 p-4 md:p-5 border-l-2 border-purple-500 bg-gradient-to-r from-purple-900/20 to-transparent rounded-r-sm">
            <h4 className="text-purple-300 font-bold tracking-wider text-xs md:text-sm mb-2 uppercase">
              {block.title}
            </h4>
            {Array.isArray(block.content) ? (
              <ul className="space-y-1">
                {block.content.map((c, i) => (
                  <li key={i} className="text-xs md:text-sm text-gray-400 flex gap-2">
                    <span className="opacity-50">-</span> {c}
                  </li>
                ))}
              </ul>
            ) : (
              <p className="text-xs md:text-sm text-gray-400 leading-relaxed">
                {block.content}
              </p>
            )}
          </div>
        );

      default:
        return null;
    }
  };

  return (
    <div className="relative w-full h-[100dvh] flex flex-col items-center overflow-hidden">
      
      {/* 1. GLASS HEADER */}
      <div className="z-20 w-full p-4 md:p-6 flex justify-between items-center border-b border-white/10 bg-black/20 backdrop-blur-md shrink-0">
        <div>
          <h1 className="text-2xl md:text-3xl font-black tracking-tighter text-white drop-shadow-[0_0_10px_rgba(255,255,255,0.5)]">
            {CONTENT[lang].title}
          </h1>
          <div className="flex items-center gap-2 mt-1">
            <span className="w-2 h-2 bg-purple-500 rounded-full animate-pulse"></span>
            <p className="text-[10px] md:text-xs text-purple-300 tracking-[0.2em]">
              {CONTENT[lang].subtitle}
            </p>
          </div>
        </div>

        {/* TERMINAL TOGGLE */}
        <div className="flex bg-black/40 rounded border border-gray-700">
          <button 
            onClick={() => setLang('en')}
            className={clsx("px-3 py-1 text-xs font-bold transition-all", lang === 'en' ? "bg-purple-600 text-white" : "text-gray-500 hover:text-white")}
          >
            EN
          </button>
          <div className="w-px bg-gray-700"></div>
          <button 
            onClick={() => setLang('fa')}
            className={clsx("px-3 py-1 text-xs font-bold transition-all font-sans", lang === 'fa' ? "bg-purple-600 text-white" : "text-gray-500 hover:text-white")}
          >
            FA
          </button>
        </div>
      </div>

      {/* 2. SCROLLABLE CONTENT */}
      <div className="z-10 w-full max-w-4xl flex-1 overflow-y-auto custom-scrollbar p-4 md:p-8 pb-32 touch-pan-y">
        <AnimatePresence mode='wait'>
          <motion.div
            key={lang}
            initial={{ opacity: 0, x: -10 }}
            animate={{ opacity: 1, x: 0 }}
            exit={{ opacity: 0, x: 10 }}
            transition={{ duration: 0.2 }}
            dir={lang === 'fa' ? 'rtl' : 'ltr'}
            className={clsx("space-y-10", lang === 'fa' ? 'font-sans' : 'font-mono')}
          >
            
            {CONTENT[lang].sections.map((section) => (
              <div key={section.id} className="relative group">
                {/* Decorative Brackets */}
                <div className="absolute -left-2 -top-2 w-4 h-4 border-l-2 border-t-2 border-gray-700 group-hover:border-purple-500 transition-colors"></div>
                <div className="absolute -right-2 -top-2 w-4 h-4 border-r-2 border-t-2 border-gray-700 group-hover:border-purple-500 transition-colors"></div>

                {/* Glass Panel */}
                <div className="bg-black/30 border border-white/10 backdrop-blur-sm p-6 md:p-8 rounded-sm hover:border-purple-500/30 transition-all">
                    
                    {/* Section Header */}
                    <div className="flex items-center gap-3 mb-6 border-b border-white/5 pb-4">
                        <div className={`w-1 h-6 ${section.color} bg-current shadow-[0_0_10px_currentColor]`}></div>
                        <h2 className={`text-xl md:text-2xl font-black tracking-widest text-white uppercase`}>
                            {section.title}
                        </h2>
                    </div>

                    {/* Dynamic Block Rendering */}
                    <div className="pl-1">
                      {section.blocks.map((block, idx) => renderBlock(block, idx))}
                    </div>

                    {/* Footer Data */}
                    {section.footer && (
                      <div className="mt-8 pt-4 border-t border-gray-800 text-[10px] font-bold text-gray-600 tracking-widest flex items-center justify-end gap-2">
                        {section.footer}
                        <div className="w-1.5 h-1.5 rounded-full bg-gray-600"></div>
                      </div>
                    )}
                </div>
              </div>
            ))}

            {/* Empty State Fallback (remove this when data is injected if not needed) */}
            {CONTENT[lang].sections.length === 0 && (
              <div className="text-center py-20 text-gray-500 animate-pulse">
                AWAITING DATA INJECTION...
              </div>
            )}

          </motion.div>
        </AnimatePresence>
      </div>

      {/* 3. FOOTER */}
      <div className="fixed bottom-0 w-full p-6 bg-gradient-to-t from-black via-black/90 to-transparent z-30 flex justify-center shrink-0">
        <Link to="/">
          <button className="group relative px-12 py-4 bg-black/40 border border-purple-500/50 text-purple-400 font-black tracking-[0.2em] hover:bg-purple-500 hover:text-white transition-all text-xs md:text-sm overflow-hidden backdrop-blur-md">
            <span className="relative z-10">{CONTENT[lang].back}</span>
            <div className="absolute inset-0 bg-purple-600 translate-y-full group-hover:translate-y-0 transition-transform duration-300 z-0"></div>
          </button>
        </Link>
      </div>

    </div>
  );
};

export default MinimaxInfo;
--- END OF FILE: src\pages\MinimaxInfo.tsx ---


--- START OF FILE: src\pages\OfflineSetup.tsx ---
// src/pages/OfflineSetup.tsx
import { useState, useMemo } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import { useGameStore } from '../store/gameStore';
import { clsx } from 'clsx';

const OfflineSetup = () => {
  const navigate = useNavigate();
  const startGame = useGameStore(state => state.startGame);
  const setARMode = useGameStore(state => state.setARMode);

  // UI STATE
  // We use a float for smooth sliding, but round it for Game Logic
  const [rawDifficulty, setRawDifficulty] = useState(3.0); 
  const [isAR, setIsAR] = useState(false);

  // Derived integer for display and logic
  const displayLevel = Math.round(rawDifficulty);

  // THEME LOGIC (Smooth Transitions)
  const theme = useMemo(() => {
    if (rawDifficulty < 3) return { color: 'text-neon-green', border: 'border-neon-green', bg: 'bg-neon-green', label: 'TRAINING', glow: 'shadow-neon-green/50' };
    if (rawDifficulty < 6) return { color: 'text-neon-blue', border: 'border-neon-blue', bg: 'bg-neon-blue', label: 'STANDARD', glow: 'shadow-neon-blue/50' };
    if (rawDifficulty < 9) return { color: 'text-neon-pink', border: 'border-neon-pink', bg: 'bg-neon-pink', label: 'ADVANCED', glow: 'shadow-neon-pink/50' };
    // GOLD TIER (9.0 - 10.0)
    return { color: 'text-yellow-400', border: 'border-yellow-400', bg: 'bg-yellow-400', label: 'NIGHTMARE', glow: 'shadow-yellow-400/50' };
  }, [rawDifficulty]);

  const handleLaunch = () => {
    setARMode(isAR);
    startGame(displayLevel); 
    navigate('/game');
  };

  return (
    <div className="relative w-full h-[100dvh] text-white font-mono flex flex-col items-center overflow-hidden">
      
      {/* 1. HEADER */}
      <div className="z-20 w-full p-4 md:p-6 flex justify-between items-center border-b border-white/10 bg-black/20 backdrop-blur-md shrink-0">
        <div>
          <h1 className="text-2xl md:text-3xl font-black tracking-tighter text-white drop-shadow-[0_0_10px_rgba(255,255,255,0.5)]">
            MISSION_SETUP
          </h1>
          <div className="flex items-center gap-2 mt-1">
            <span className={`w-2 h-2 rounded-full animate-pulse ${theme.bg}`}></span>
            <p className={`text-[10px] md:text-xs tracking-[0.2em] ${theme.color} transition-colors duration-300`}>
              {theme.label} PROTOCOL
            </p>
          </div>
        </div>

        <Link to="/">
          <button className="px-4 py-2 text-xs font-bold text-gray-400 hover:text-white border border-transparent hover:border-gray-600 rounded transition-all bg-black/40">
            &lt; ABORT
          </button>
        </Link>
      </div>

      {/* 2. MAIN CONTENT AREA */}
      <div className="z-10 w-full max-w-md flex-1 flex flex-col justify-center p-6 gap-6 overflow-y-auto custom-scrollbar touch-pan-y">
        
        {/* --- THE COMMAND BOX --- */}
        <div className="relative group">
            {/* Brackets */}
            <div className={`absolute -left-2 -top-2 w-4 h-4 border-l-2 border-t-2 ${theme.border} transition-colors duration-500`}></div>
            <div className={`absolute -right-2 -bottom-2 w-4 h-4 border-r-2 border-b-2 ${theme.border} transition-colors duration-500`}></div>

            <div className="bg-black/40 border border-white/10 backdrop-blur-md p-6 rounded-lg flex flex-col gap-8 shadow-lg">
                
                {/* A. SMOOTH DIFFICULTY SLIDER */}
                <div>
                    <div className="flex justify-between items-end mb-4">
                        <label className={`text-[10px] font-bold tracking-widest ${theme.color} transition-colors duration-300`}>
                            AI NEURAL DEPTH
                        </label>
                        <span className="text-xs font-bold text-white bg-black/50 px-3 py-1 rounded border border-white/10 min-w-[3rem] text-center">
                            LVL {displayLevel}
                        </span>
                    </div>
                    
                    <div className="relative h-8 flex items-center">
                        {/* Track Background */}
                        <div className="absolute w-full h-1 bg-gray-800 rounded-full overflow-hidden"></div>
                        
                        {/* Active Track (Colored) */}
                        <div 
                            className={`absolute h-1 rounded-full ${theme.bg} transition-colors duration-300 shadow-[0_0_10px_currentColor]`} 
                            style={{ width: `${((rawDifficulty - 1) / 9) * 100}%` }}
                        ></div>

                        {/* Circular Thumb */}
                        <div 
                            className={`
                                absolute h-6 w-6 rounded-full bg-black border-2 ${theme.border} 
                                shadow-lg z-10 pointer-events-none transition-colors duration-300
                                flex items-center justify-center
                            `}
                            style={{ 
                                left: `calc(${((rawDifficulty - 1) / 9) * 100}%)`,
                                transform: 'translateX(-50%)' // Center the circle on the value
                            }}
                        >
                            {/* Inner Dot */}
                            <div className={`w-2 h-2 rounded-full ${theme.bg}`}></div>
                        </div>

                        {/* Invisible Input (Captures Touch/Drag) */}
                        <input 
                            type="range" 
                            min="1" 
                            max="10" 
                            step="0.1" // Smooth steps
                            value={rawDifficulty} 
                            onChange={(e) => setRawDifficulty(parseFloat(e.target.value))}
                            className="absolute w-full h-full opacity-0 cursor-pointer z-20"
                        />
                    </div>
                    
                    <div className="flex justify-between text-[9px] text-gray-600 font-bold mt-1">
                        <span>NOVICE</span>
                        <span>STANDARD</span>
                        <span className={rawDifficulty >= 9 ? "text-yellow-500 animate-pulse" : ""}>GODLIKE</span>
                    </div>
                </div>

                {/* B. AR TOGGLE */}
                <div 
                    onClick={() => setIsAR(!isAR)}
                    className={clsx(
                        "cursor-pointer p-4 rounded border transition-all duration-300 flex items-center justify-between group/ar",
                        isAR ? `bg-white/5 ${theme.border}` : "bg-black/30 border-gray-700 hover:border-gray-500"
                    )}
                >
                    <div className="flex flex-col gap-1">
                        <span className={clsx("text-[10px] font-black tracking-widest transition-colors", isAR ? theme.color : "text-gray-400")}>
                            AR_PASSTHROUGH
                        </span>
                        <span className="text-[9px] text-gray-500">
                            {isAR ? "CAMERA FEED ACTIVE" : "STANDARD 3D VIEW"}
                        </span>
                    </div>
                    
                    {/* Switch UI */}
                    <div className={clsx("w-10 h-5 rounded-full relative transition-colors duration-300", isAR ? theme.bg : "bg-gray-800")}>
                        <div className={clsx("absolute top-1 w-3 h-3 bg-black rounded-full shadow-md transition-transform duration-300", isAR ? "left-6" : "left-1")}></div>
                    </div>
                </div>

                {/* C. LAUNCH BUTTON */}
                <button 
                    onClick={handleLaunch}
                    onMouseEnter={() => import('./GameSession')} 
                    className={`
                        w-full py-4 border font-black tracking-[0.2em] transition-all rounded shadow-lg active:scale-[0.98]
                        ${theme.border} ${theme.color} hover:text-black bg-black/20
                        hover:${theme.bg} hover:shadow-[0_0_20px_currentColor]
                    `}
                >
                    INITIALIZE SYSTEM
                </button>

            </div>
        </div>

        {/* --- FOOTER SPECS --- */}
        <div className="flex justify-between items-center px-4 opacity-50">
            <span className="text-[9px] text-gray-500 tracking-widest">GRID: 6x6 MATRIX</span>
            <span className="text-[9px] text-gray-500 tracking-widest">SEED: QUANTUM_RNG</span>
        </div>

      </div>

    </div>
  );
};

export default OfflineSetup;
--- END OF FILE: src\pages\OfflineSetup.tsx ---


--- START OF FILE: src\store\gameStore.ts ---
// src/store/gameStore.ts
import { create } from 'zustand';
import { io, Socket } from 'socket.io-client';
import { 
  createInitialBoard, 
  applyQuantumMove, 
  collapseBoard, 
  calculateScore,
  isBoardFull,
  TOTAL_CELLS,
  type GateType,
  type Qubit,
  type Player
} from '../engine/core/QuantumLogic';

// OPTIMIZATION #4: Robust Worker Queue
import MinimaxWorker from '../engine/ai/minimax.worker?worker';

class WorkerQueue {
  private workers: Worker[] = [];
  private busy: boolean[] = [];
  private queue: Array<{ data: any, resolve: (val: any) => void }> = [];

  constructor(size: number) {
    for (let i = 0; i < size; i++) {
      this.workers.push(new MinimaxWorker());
      this.busy.push(false);
      this.workers[i].onmessage = (e) => this.onWorkerMessage(i, e.data);
    }
  }

  compute(board: Qubit[], difficulty: number, player: Player): Promise<any> {
    return new Promise((resolve) => {
      // OPTIMIZATION #7: Serialize Board to Int8Array
      const serializedBoard = new Int8Array(36);
      board.forEach((q, i) => {
        if (q.status === null) serializedBoard[i] = 0;
        else {
          const sign = (q.owner === 'blue' || q.fluxOwner === 'blue') ? 1 : -1;
          if (q.status === 'STABLE') serializedBoard[i] = 1 * sign;
          else if (q.status === 'LOCKED') serializedBoard[i] = 2 * sign;
          else if (q.status === 'FLUX') serializedBoard[i] = 3 * sign;
        }
      });
      
      // Transferable object structure
      const taskData = { 
        board: serializedBoard, // Int8Array
        difficulty, 
        player 
      };

      const availableWorkerId = this.busy.findIndex(b => !b);
      if (availableWorkerId !== -1) {
        this.runWorker(availableWorkerId, taskData, resolve);
      } else {
        this.queue.push({ data: taskData, resolve });
      }
    });
  }

  private runWorker(id: number, taskData: any, resolve: (val: any) => void) {
    this.busy[id] = true;
    // Store resolve function on the worker instance (hacky but fast) or map
    (this.workers[id] as any)._currentResolve = resolve;
    // Optimization: Transfer buffer ownership to worker
    this.workers[id].postMessage(taskData, [taskData.board.buffer]);
  }

  private onWorkerMessage(id: number, result: any) {
    const resolve = (this.workers[id] as any)._currentResolve;
    if (resolve) resolve(result);
    this.busy[id] = false;

    if (this.queue.length > 0) {
      const next = this.queue.shift()!;
      this.runWorker(id, next.data, next.resolve);
    }
  }
}

const aiSystem = new WorkerQueue(2); // Pool of 2 workers

let socket: Socket | null = null;
let reconnectInterval: ReturnType<typeof setInterval> | null = null;

interface GameState {
  board: Qubit[];
  currentPlayer: Player; 
  turns: number;
  instability: number;
  status: 'idle' | 'playing' | 'collapsing' | 'gameover' | 'waiting_for_opponent';
  winner: Player | 'draw' | null;
  scores: { blue: number, red: number };
  
  selectedGate: GateType;
  draggingGate: GateType | null;
  hoveredCell: number | null;

  isARMode: boolean;
  difficulty: number;
  isAIThinking: boolean; 

  arScale: number; 
  isARPlaced: boolean;

  isMultiplayer: boolean;
  myRole: Player;
  roomId: string | null;
  opponentDisconnected: boolean;
  isLoading: boolean;

  setSelectedGate: (gate: GateType) => void;
  setDraggingGate: (gate: GateType | null) => void;
  setHoveredCell: (id: number | null) => void;
  setARMode: (enabled: boolean) => void;
  setARPlaced: (placed: boolean) => void;
  setLoading: (loading: boolean) => void;

  startGame: (difficulty: number) => void;
  joinMultiplayerRoom: (roomId: string) => void;
  exitGame: () => void;
  executeMove: (nodeId: number, gate: GateType, isNetworkMove?: boolean, networkSeed?: number) => void;
}

export const useGameStore = create<GameState>((set, get) => ({
  board: createInitialBoard(),
  currentPlayer: 'blue', 
  turns: 0,
  instability: 0,
  status: 'idle',
  winner: null,
  scores: { blue: 0, red: 0 },
  selectedGate: 'X', 
  draggingGate: null,
  hoveredCell: null,
  isARMode: false,
  difficulty: 3,
  isAIThinking: false, 
  arScale: 0.04, 
  isARPlaced: false,
  isMultiplayer: false,
  myRole: null,
  roomId: null,
  opponentDisconnected: false,
  isLoading: false,

  setSelectedGate: (gate) => set({ selectedGate: gate }),
  setDraggingGate: (gate) => set({ draggingGate: gate }),
  setHoveredCell: (id) => set({ hoveredCell: id }),
  setARMode: (enabled) => set({ isARMode: enabled }),
  setARPlaced: (placed) => set({ isARPlaced: placed }),
  setLoading: (loading) => set({ isLoading: loading }),

  startGame: (difficulty) => {
    set({ isLoading: true });
    setTimeout(() => {
        set({
          board: createInitialBoard(),
          difficulty: difficulty,
          currentPlayer: 'blue',
          turns: 0,
          instability: 0,
          status: 'playing',
          winner: null,
          scores: { blue: 0, red: 0 },
          isMultiplayer: false,
          opponentDisconnected: false,
          isAIThinking: false,
          hoveredCell: null,
          isARPlaced: false,
          isLoading: false 
        });
    }, 500);
  },

  joinMultiplayerRoom: (roomId) => {
    const sanitizedId = roomId.trim().toUpperCase().replace(/[^A-Z0-9-]/g, '').slice(0, 12);
    if (sanitizedId.length < 3) return;

    set({ isLoading: true });

    if (socket) {
        socket.removeAllListeners(); // OPTIMIZATION #3: Clear old listeners
        socket.disconnect();
    }
    
    socket = io({ 
      path: '/socket.io',
      reconnectionAttempts: 5,
      transports: ['websocket'] 
    });

    socket.emit('join_room', sanitizedId);

    set({ 
      isMultiplayer: true, 
      roomId: sanitizedId, 
      status: 'waiting_for_opponent',
      board: createInitialBoard(),
      turns: 0,
      instability: 0,
      scores: { blue: 0, red: 0 },
      opponentDisconnected: false,
      hoveredCell: null,
      isARPlaced: false,
      isLoading: false 
    });

    // --- SOCKET HANDLERS ---
    const setupHandlers = (s: Socket) => {
        s.removeAllListeners(); // Ensure cleanliness
        
        s.on('role_assigned', (role: Player) => set({ myRole: role }));
        
        s.on('game_start', () => {
          set({ status: 'playing', currentPlayer: 'blue' });
        });
        
        s.on('opponent_move', (data) => {
          get().executeMove(data.nodeId, data.gate, true, data.seed);
        });

        s.on('disconnect', () => {
          set({ opponentDisconnected: true });
          
          let attempts = 0;
          reconnectInterval = setInterval(() => {
            if (!s || attempts >= 5) {
              if (reconnectInterval) clearInterval(reconnectInterval);
              return;
            }
            console.log('Attempting reconnection...');
            s.connect();
            attempts++;
          }, 2000);
        });

        s.on('connect', () => {
            if (reconnectInterval) clearInterval(reconnectInterval);
            set({ opponentDisconnected: false });
            if (get().roomId) s.emit('join_room', get().roomId);
        });

        s.on('player_left', () => {
          set({ opponentDisconnected: true });
        });
    };

    setupHandlers(socket);
  },

  exitGame: () => {
    if (socket) {
      socket.removeAllListeners();
      socket.disconnect();
      socket = null;
    }
    if (reconnectInterval) clearInterval(reconnectInterval);
    
    set({
      status: 'idle',
      isMultiplayer: false,
      opponentDisconnected: false,
      winner: null,
      board: createInitialBoard(),
      hoveredCell: null,
      isAIThinking: false,
      isLoading: false
    });
  },

  executeMove: (nodeId, gate, isNetworkMove = false, networkSeed?: number) => {
    const state = get();
    if (state.status !== 'playing') return;
    if (!isNetworkMove && state.isAIThinking) return;

    const moveSeed = isNetworkMove && networkSeed !== undefined ? networkSeed : Math.floor(Math.random() * 1000000);

    if (state.isMultiplayer && !isNetworkMove) {
      if (state.currentPlayer !== state.myRole) return;
      if (!socket) return;
      socket.emit('make_move', { roomId: state.roomId, nodeId, gate, seed: moveSeed });
    }

    const targetNode = state.board[nodeId];
    if (!targetNode || targetNode.status !== null) return;

    // Apply Move
    const newBoard = applyQuantumMove(state.board, nodeId, gate, state.currentPlayer, moveSeed);
    const newTurns = state.turns + 1;
    const newInstability = (newTurns / TOTAL_CELLS) * 100;
    const currentScores = calculateScore(newBoard);

    // End Game Check
    if (newTurns >= TOTAL_CELLS || isBoardFull(newBoard)) {
      // OPTIMIZATION #5: Batched Update (Collapse)
      set({ 
          board: newBoard, 
          turns: newTurns, 
          instability: 100, 
          status: 'collapsing', 
          draggingGate: null, 
          isAIThinking: false 
      });
      
      setTimeout(() => {
        const finalBoard = collapseBoard(newBoard, moveSeed);
        const finalScores = calculateScore(finalBoard);
        let winner: Player | 'draw' = 'draw';
        if (finalScores.blue > finalScores.red) winner = 'blue';
        if (finalScores.red > finalScores.blue) winner = 'red';
        
        set({ board: finalBoard, scores: finalScores });
        setTimeout(() => { set({ status: 'gameover', winner: winner }); }, 2500);
      }, 1500);
      return;
    }

    const nextPlayer = state.currentPlayer === 'blue' ? 'red' : 'blue';

    // OPTIMIZATION #5: Batched Update (Next Turn)
    set({ 
        board: newBoard, 
        turns: newTurns, 
        instability: newInstability, 
        currentPlayer: nextPlayer, 
        scores: currentScores, 
        draggingGate: null 
    });

    // AI Trigger
    if (!state.isMultiplayer && nextPlayer === 'red') {
      set({ isAIThinking: true });
      
      aiSystem.compute(newBoard, state.difficulty, 'red')
        .then((aiMove) => {
             // Small delay for pacing
             setTimeout(() => {
                set({ isAIThinking: false }); 
                if (aiMove) get().executeMove(aiMove.id, aiMove.gate, true); 
             }, 400);
        });
    }
  },
}));

// Selectors
export const useScores = () => useGameStore(state => state.scores);
export const useInstability = () => useGameStore(state => state.instability);
export const useBoard = () => useGameStore(state => state.board);
export const useStatus = () => useGameStore(state => state.status);
--- END OF FILE: src\store\gameStore.ts ---
